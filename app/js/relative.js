$( document ).ready(function() {
	// Default Project Cue animation
	var cueAnimation = {"v":"4.6.2","fr":30,"ip":0,"op":119,"w":1366,"h":768,"nm":"Comp 1","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[100]},{"t":66}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[389,458.994,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":2,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[100]},{"t":84}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[389,392,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":3,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[100]},{"t":23}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[693,324,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":4,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":23,"s":[5],"e":[100]},{"t":100}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[693,392,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":5,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[100]},{"t":100}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[859,392,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":6,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[100]},{"t":93}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[859,458,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":7,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":12,"s":[0],"e":[100]},{"t":93}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[927,458,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":8,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":12,"s":[0],"e":[100]},{"t":102}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[927,324,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":9,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[100]},{"t":102}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[859,324,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":10,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":29,"s":[0],"e":[100]},{"t":30}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[791,324,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":11,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":29,"s":[0],"e":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":30,"s":[100],"e":[100]},{"t":91}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[791,392,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":12,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[100]},{"t":107}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[791,460,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":13,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":59,"s":[0],"e":[100]},{"t":90}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[693,460,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":14,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":25,"s":[0],"e":[100]},{"t":64}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[625,460,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":15,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":14,"s":[0],"e":[100]},{"t":75}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[557,324,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":16,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":40,"s":[0],"e":[100]},{"t":112}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[557,392,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":17,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":11,"s":[0],"e":[100]},{"t":108}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[557,460,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":18,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":83,"s":[4],"e":[100]},{"t":109}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[457,460,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":19,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":71,"s":[0],"e":[100]},{"t":112}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[457,324,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":20,"ty":1,"nm":"Royal Blue Solid 1","ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[14],"e":[100]},{"t":94}]},"r":{"a":0,"k":0},"p":{"a":0,"k":[389,324.657,0]},"a":{"a":0,"k":[32,32,0]},"s":{"a":0,"k":[100,100,100]}},"ao":0,"sw":64,"sh":64,"sc":"#0064ff","ip":0,"op":123,"st":0,"bm":0,"sr":1}]}

	// Check to see if there is an animation stored locally & load animation
	var getAnimation = localStorage.getItem("projectAniData");
	getAnimation = JSON.parse(getAnimation);
	if (getAnimation != null) {
		renderAnimation(getAnimation);
		addAnimationListener()
		$('.deleteAni').show();
	}
	else {
		$('.deleteAni').hide();
		renderAnimation(cueAnimation);
		addAnimationListener()
	}
	$("#selectFiles").change(function(){
		var name = document.getElementById('selectFiles')
		var files = document.getElementById('selectFiles').files;
		var currentProject = $('.selectedProject').text();
		if (files.length <= 0) {
		    return false;
		}
	  	var fr = new FileReader(); 
		fr.onload = function(e) { 
	  		var fileContent = e.target.result
	  		friendlyName = files[0].name
	  		friendlyName = friendlyName.replace(/\.json/g, '');
			document.getElementById('result').value = fileContent;
			var result = $('#result');
		  	result = result.val();
		  	result = JSON.parse(result);
		  	actualyName = result.nm;
		  	checkAssets = result.assets
		  	imageCount = 0
		  	compCount = 0
		  	for (i = 0; i < checkAssets.length; i++) { 
			    var assetType = checkAssets[i].id
			    var assetTypeImage = assetType.includes("image");
			    var assetTypeComp = assetType.includes("comp");
			    if (assetTypeImage === true) {
			    	imageCount++	
			    }
			    if (assetTypeComp === true) {
			    	compCount++	
			    }
			}
		  	result = parseInt(result.v);
		  	// Check to see if this json includes images (assets > 0)
		  	if (result >= 4) {
		  		if (imageCount > 0) {
		  			$('.fileToUpload').fadeIn('fast')
		  			$('.fileToUpload').html(actualyName+' appears to reference '+imageCount+' images. Unfortunately, images are not supported in this version of Cue.');
		  			$('.pickProject').hide();
		  			$('.submitBtn').prop('disabled', false);
		  			//$('.skipToAnimation').show();
		  			// $('#selectFiles').hide(); 
		  			// $('#selectImages').show(); // Use this for triggering image upload
		  			$('#uploadProgress').fadeIn('fast');
					$( ".submitBtn" ).trigger( "click" );
		  		}
		  		else if (compCount > 0) {
		  			$('.fileToUpload').fadeIn('fast')
		  			$('.fileToUpload').html('Unfortunetly pre-comps are not supported yet');
		  			$('#result').val('');
			  	}
			  	else {
			  		$('.submitBtn').prop('disabled', false);
			  		$( ".submitBtn" ).trigger( "click" );
			  	}
		  		
		  	}

		}
		fr.readAsText(files.item(0));
	});

	// File upload
	$('.fileToUpload').on('click', '.removeFile', function(e) {
		$('#createProject').val('');
		$('#result').val('');
		$('.fileToUpload').html('');
		$('.submitBtn').prop('disabled', true);
		$('.pickProject').show();
		$('.submitBtn').hide();
		$('.skipToAnimation').hide();
		$('#selectFiles').show();
		$('#selectImages').hide();
	});

	$('.skipToAnimation').on('click', function() {
		$( ".uploadJSON" ).trigger( "click" );
	});

	// Delete Animation Button
	$('.deleteAni').on('click', function() {
		$('.deleteAnimationAlert').show();
	});

	$('.yesDelete').on('click', function() {
		localStorage.removeItem("projectAniData");
		location.reload();
		$('.deleteAnimationAlert').fadeOut('fast');
	});

	// Delete Animation Button
	$('.noDelete').on('click', function() {
		$('.deleteAnimationAlert').fadeOut('fast');
	});

	// Update & Reload URL with Animation #
	function addAnimationListener() {
			// Layer UI Controls if clicked from animation element
		$('.elements-reset').on('click', '> div, > svg', function() {
			var className = $(this).attr('class');
	    	var className = '#'+className+'-ui';
			$(className).toggleClass('expand');
			$(className).children('.transform').toggleClass('expand');
			$(className).children('.trigger').toggleClass('collapse');

			$(className).find('.timelineHighlight').removeClass('active');
			$(className).find('.keyframe').removeClass('active');
			$(className).find('.keyframe').find('.timeUI').removeClass('show');
			$(className).find('.timeline').parent('.wrapTimeline').removeClass('open');
		});

	}
 
	
	// Submit the animations to Firebase
	$('.submitBtn').click(function(){
	  	var result = $('#result');
	  	result = result.val();
	  	checkResult = JSON.parse(result);
	  	checkAssets = checkResult.assets
	  	checkAssets = checkAssets.length
  		if (result < 1) {
  			console.log('no submission')
  		}
		else {
		}
		if (checkAssets > 0) {
		}
		else {
			localStorage.setItem("projectAniData", result);
			location.reload();			
		}
	});

	$('.overlay').click(function(){
		$(this).hide();
		$('.projectSettings').empty().hide();
	})

	$('.uploadJSON').click(function(){
		$('#uploadForm').fadeToggle('fast');
		$('.panelWrapper').toggle('fast');
		$('.animations').fadeToggle('fast');
	});


// Main Function
function renderAnimation(Data) {
	var animationData = Data;
    // Dynamic StyleSheet
    $('#dynamicStylesheet').empty();
	$("head").append("<style id='dynamicStylesheet'></style>");

	// Layer Types
	// 0 = Precomp
	// 1 = Solid
	// 2 = Image
	// 3 = Null
	// 4 = Shape
	// 5 = Text

	/**************
		Support Messaging
	***************/
	function supportMessage(layerType) {
		if (layerType === 0) {
			$('.layerTypePrecomps').html('precomps')
			$('.supportMessaging').addClass('visible');
		}
		else if (layerType === 2) {
			//$('.layerTypeImages').html('images')
			//$('.supportMessaging').addClass('visible');
		}
		else if (layerType === 4) {
			$('.layerTypeShapes').html('shapes')
			$('.supportMessaging').addClass('visible');
		}
		else if (layerType === 5) {
			$('.layerTypeText').html('text layers')
			$('.supportMessaging').addClass('visible');
		}
		else {
			$('.supportMessaging').removeClass('visible');
		}
	}

	$('.supportMessaging').on('click', 'span.dismiss', function(e) {
		$('.supportMessaging').removeClass('visible');
	})

	/**************
		Ease & Wizz Support
	***************/
    var easeWizzCurves = ["inSine", "outSine", "inOutSine", "inQuad", "outQuad", "inOutQuad", "inCubic", "outCubic", "inOutCubic", "inQuart", "outQuart", "inOutQuart", "inQuint", "outQuint", "inOutQuint", "inExpo", "outExpo", "inOutExpo", "inCirc", "outCirc", "inOutCirc", "inBack", "outBack", "inOutBack"];
	
	// Basic Animation Data
	var animationName = animationData.nm // Name of the Animation
	var frameRate = animationData.fr; // Frame Rate
	var initialFrame = animationData.ip; // Animation In Point (start of the animation)
	var finalFrame = animationData.op; // Animation Out Point (end of the animation)
	var canvasWidth = animationData.w; // Canvas Width
	var canvasHeight = animationData.h; // Canvas Height

	// Add Animation Data
	$('.canvasSize').html('Canvas Size: '+canvasWidth+'x'+canvasHeight+'');

	// Render Canvas
	$('.canvas').css({'position':'absolute', 'width': canvasWidth+'px', 'height': canvasHeight+'px', 'overflow': 'hidden', 'background-color':'#fff', 'transform-origin': '0% 0%'});

	/***************
		Define Assets & Layers
	****************/
	var assets = animationData.assets // Get assets
	var assetsLength = assets.length;

	var layers = animationData.layers // Get the Layer

	/***************
		Find Last Keyframe
	****************/

	var lastKey = []
	var lastSvgKey = []
	
	$.each(layers, function (key, layer) {
		var layerOpacityAnimated = layer.ks.o.a
		if (layerOpacityAnimated === 1) {
			var layerOpacityValue = layer.ks.o.k
			var length = layerOpacityValue.length - 1
			var opacity = layerOpacityValue[length].t
			lastKey.push(opacity);
		}

		var layerPositionSplit = layer.ks.p.s
		if (layerPositionSplit === true) {
			var layerPositionXAnimated = layer.ks.p.x.a
			if (layerPositionXAnimated === 1) {
				var layerPositionValue = layer.ks.p.x.k
				var length = layerPositionValue.length - 1
				var posX = layerPositionValue[length].t 
				lastKey.push(posX);
			}

			var layerPositionYAnimated = layer.ks.p.y.a
			if (layerPositionYAnimated === 1) {
				var layerPositionValue = layer.ks.p.y.k
				var length = layerPositionValue.length - 1
				var posY = layerPositionValue[length].t 
				lastKey.push(posY);
			}
		}
		
		var layerPositionAnimated = layer.ks.p.a
		if (layerPositionAnimated === 1) {
			var layerPositionValue = layer.ks.p.k
			var length = layerPositionValue.length - 1
			var pos = layerPositionValue[length].t 
			lastKey.push(pos);
		}

		var layerRotationAnimated = layer.ks.r.a
		if (layerRotationAnimated === 1) {
			var layerRotationValue = layer.ks.r.k
			var length = layerRotationValue.length - 1
			var rot = layerRotationValue[length].t 
			lastKey.push(rot);
		}

		var layerScaleAnimated = layer.ks.s.a
		if (layerScaleAnimated === 1) {
			var layerScaleValue = layer.ks.s.k
			var length = layerScaleValue.length - 1
			var scl = layerScaleValue[length].t
			lastKey.push(scl);
		}

		if (layer.hasMask === true) {
			var layerMaskProperties = layer.masksProperties
			for (i = 0; i < layerMaskProperties.length; i++) {
				var maskPointsAnimated = layerMaskProperties[i].pt.a // Is the mask animated, 0 or 1
				var maskPointsValues = layerMaskProperties[i].pt.k // Is the mask animated, 0 or 1
				if (maskPointsAnimated == 1) {
					var animationDuration = maskPointsValues[1].t / frameRate
					var animationDuration = animationDuration.toFixed(2) * 100
					lastSvgKey.push(animationDuration);
				}
			}
		}
	});

	var animationLength = Math.max.apply(null, lastKey);
	var layerOutPoint = animationLength
	var layerDuration = animationLength / frameRate
	var layerDuration = parseFloat(layerDuration.toFixed(2));

	var animationLengthSvg = Math.max.apply(null, lastSvgKey);
	var layerOutPointSvg = animationLengthSvg
	var layerDurationSvg = animationLengthSvg / frameRate
	var layerDurationSvg = parseFloat(layerDurationSvg.toFixed(2));

	/***************
		Loop through Layers to build UI and Keyframe Animations 
	****************/
	$.each(layers, function (key, layer) {
	
		// LAYER NAME
		var layerName = layer.nm // Layer Name
		var layerName = layerName.split(' ').join('_') // Replace spaces with underscores
		var layerName = layerName.replace('&', '');
		var layerName = layerName.replace('@', '-');
		var layerName = layerName.replace('.', '-');
		var layerName = layerName.replace('#', '-');		
		var layerName = layerName +'_'+ key
		var layerType = layer.ty // Layer Type -- See 'Layer Types'
		supportMessage(layerType)
		
		/***************
			SHAPES In Progress
		****************/

		var layerShape = layer.shapes

		if (layerShape != undefined) {
			
			var groupShape = layerShape[0].it
			
			if (groupShape != undefined) {
				for (i = 0; i < groupShape.length; i++) {

				var groupType = groupShape[i].ty
				
				
				// TRANSFORM OBJECT
				var shapeTransformData = layerShape[0].it.length - 1

				// SHAPE POSITION: Used to offset the overall position
				var shapePositionXAdjust = layerShape[0].it[shapeTransformData].p.k[0]
				var shapePositionYAdjust = layerShape[0].it[shapeTransformData].p.k[1]


				// SHAPE SIZE: Width & Height
				if (layerShape[0].it[0].s) {
					var shapeWidth = layerShape[0].it[0].s.k[0]
					var shapeWidth = Math.round(shapeWidth);
					var shapeHeight = layerShape[0].it[0].s.k[1]
					var shapeHeight = Math.round(shapeHeight);	
				}

				// Stroke
				if (groupType === 'st') {
					if (layerShape[0].it[1].w.k) {
						var shapeStrokeSize = layerShape[0].it[1].w.k
						var shapeStrokeColorR = Math.round((layerShape[0].it[1].c.k[0] * 255));
						var shapeStrokeColorG = Math.round((layerShape[0].it[1].c.k[1] * 255));
						var shapeStrokeColorB = Math.round((layerShape[0].it[1].c.k[2] * 255));
						var shapeStrokeColorA = layerShape[0].it[1].c.k[3] * 100
						var shapeStrokeColorRGBA = 'rgba('+shapeStrokeColorR+', '+shapeStrokeColorG+', '+shapeStrokeColorB+', '+shapeStrokeColorA+')'
						var shapeStroke = 'border: '+shapeStrokeSize+'px solid '+shapeStrokeColorRGBA
					}
				}

				// Fill
				if (groupType === 'fl') {
					var shapeColor = groupShape[i].c
					var shapeColorAnimated = groupShape[i].c.a
					var shapeColorR = Math.round((groupShape[i].c.k[0] * 255));
					var shapeColorG = Math.round((groupShape[i].c.k[1] * 255));
					var shapeColorB = Math.round((groupShape[i].c.k[2] * 255));
					var shapeColorA = groupShape[i].c.k[3] * 100
					var shapeColorRGBA = 'rgba('+shapeColorR+', '+shapeColorG+', '+shapeColorB+', '+shapeColorA+')'
				}


				// Transform
				if (groupType === 'tr') {
				}
					

				// Ellipsis
				if (groupType === 'el') {
					var shapeSizeAnimated = layerShape[0].it[0].s.a
					var shapeCircle = 'el';
				}

				// Star
				if (groupType === 'sr') {
				}

				
				// Shape
				if (groupType === 'sh') {
					var layerShapeProperties = layerShape[0].it[0].ks

					//buildSVG = '<svg xmlns="http://www.w3.org/2000/svg" class="'+layerName+'" width="'+canvasWidth+'" height="'+canvasHeight+'" viewBox="0 0 '+canvasWidth+' '+canvasHeight+'" style="width: 100%; height: 100%">'
					buildSVG = '<svg class="'+layerName+'" width="'+canvasWidth+'" height="'+canvasHeight+'">'

					var shapePointsAnimated = layerShapeProperties.a // Is the shape animated, 0 or 1
					var shapePointValues = layerShapeProperties.k.v // Is the mask animated, 0 or 1

					// Generate shape RGBA for background-color
					var shColorProperties = layerShape[0].it[1].c.k
					var shColorPropertiesR = Math.round((shColorProperties[0] * 255));
					var shColorPropertiesG = Math.round((shColorProperties[1] * 255));
					var shColorPropertiesB = Math.round((shColorProperties[2] * 255));
					var shColorPropertiesA = shColorProperties[3] * 100
					var shColorRGBA = 'rgba('+shColorPropertiesR+', '+shColorPropertiesG+', '+shColorPropertiesB+', '+shColorPropertiesA+')'
					

					if (shapePointsAnimated == 0) {
					 	var pathNodes = layerShapeProperties.k
					 	forMaskLoop = shapePointValues
					 	var shapeClosed = layerShapeProperties.k.c // Is the path closed, true or false
					 	//var dPath = 'M0 0 '// Start Creating the svg path
					 	var dPath = 'M'+shapePointValues[0] // Start Creating the svg path
						for (d = 1; d < forMaskLoop.length; d+=1) {
							dPath += ' C'+ (pathNodes.o[d - 1][0] + pathNodes.v[d - 1][0]) + ',' + (pathNodes.o[d - 1][1] + pathNodes.v[d - 1][1]) +' '+  (pathNodes.i[d][0] + pathNodes.v[d][0]) + ',' + (pathNodes.i[d][1] + pathNodes.v[d][1]) +' '+ (pathNodes.v[d][0])+ ',' + (pathNodes.v[d][1])
						}
						
						if(shapeClosed && forMaskLoop.length > 1){
							dPath += ' C'+ (pathNodes.o[d - 1][0] + pathNodes.v[d - 1][0]) + ',' + (pathNodes.o[d - 1][1] + pathNodes.v[d - 1][1]) +' '+  (pathNodes.i[0][0] + pathNodes.v[0][0]) + ',' + (pathNodes.i[0][1] + pathNodes.v[0][1]) +' '+ (pathNodes.v[0][0])+ ',' + (pathNodes.v[0][1])
						}

						buildSVG += '<path transform="matrix(1,0,0,1,658,454)" fill="'+shColorRGBA+'" d="'+dPath+'z"></path>';
					}
	
					buildSVG += '</svg>'
					$('.elements-reset').append(buildSVG);		

					// Used to indicate a transparent background on shape svg
					var backgroundColorShape = true			
				}

				// Rounded Corners
				if (groupType === 'rd') {

				}

				// Rectangle
				if (groupType === 'rc') {
					var shapeSizeAnimated = layerShape[0].it[0].s.a
					var roundedCorners = layerShape[0].it[0].r.k
				}


			}
			}
			
			
		}

		// LAYER INFO		
		var layer3d = layer.ddd // Is the layer 3d - 0 or 1
		var layerIndex = layer.ind // Layer Index 
		var layerClass = '.' + layerName // This may need unique 
		var layerID = layer.ln // Layer ID
		var layerInPoint = layer.ip // Layer In Point (where the layers first keyframe is)
		var layerStartTime = layer.st // The start time of the layer
		var layerColor = layer.sc // Layer Color (applies to solids & shapes)
		var layerAsset = layer.refId // Reference ID to Asset
		var layerHeight = layer.sh // Layer Height
		if (layerHeight === undefined) { // If there is no layer height, there will be an image height
			if (layerAsset === undefined) {
				layerHeight = shapeHeight
			}
			else {
				var newKey = layerAsset.split("_").pop();
				layerHeight = assets[newKey].h // image height
			}
		}
		var layerWidth = layer.sw // Layer Width
		if (layerWidth === undefined) { // If there is no layer width, there will be an image width
			if (layerAsset === undefined) {
				layerWidth = shapeWidth
			}
			else {
				var newKey = layerAsset.split("_").pop();
				layerWidth = assets[newKey].w
			}
		}
		
		var layerBlendMode = layer.bm // Layer Blend Mode
		var layerTimeStretch = layer.sr // Layer Time Stretching 
		var layerHasMask = layer.hasMask // Detect if Layer has Mask
		var layerMaskParent = layer.td // Detect if Layer IS a parent mask to another layer, 0 or 1
		var layerMaskChild = layer.tt // Detect if Layer IS a child mask to another layer, 0 or 1

		// Variables for keyframe styles & keyframe UI
		keyframeStyles = ''
		keyframeUI = ''


		/***************
			Mask  IN PROGRESS
		****************/
		// Call out mask mode for parent mask trakmat
		if (layerHasMask === true) {
			var layerMaskProperties = layer.masksProperties
			for (i = 0; i < layerMaskProperties.length; i++) {
				var maskMode = layerMaskProperties[i].mode
				if (maskMode === 'a') {
					maskMode = 'alpha'
				}
				else if (maskMode === 's') {
					maskMode = 'unset'
				}
			}
		}

		if (layerHasMask === true) {
			var layerMaskProperties = layer.masksProperties
			buildSVG = '<svg class="'+layerName+'" width="'+layerWidth+'" height="'+layerHeight+'" data-attribute="mask"><mask id="'+layerName+'-mask" mask-type="'+maskMode+'">'

			for (i = 0; i < layerMaskProperties.length; i++) {
				var maskInverted = layerMaskProperties[i].inv // Mask Inverted
				var maskMode = layerMaskProperties[i].mode // Mask Mode (n=None, a=Additive, s=Subtract, i=Intersect, l=Lighten, d=Darken, f=Difference)
				if (maskMode === 'a') {
					var maskMode = '#ffffff'
				}
				else if (maskMode === 's') {
					var maskMode = '#000000'
				}

				var maskName = layerMaskProperties[i].nm // Mask Name
				var maskOpacity = layerMaskProperties[i].o // Mask opacity - object
				var maskOpacityAnimated = layerMaskProperties[i].o.a // Is the opacity animated, 0 or 1
				var maskOpacityValue = layerMaskProperties[i].o.k // Opacity Values
				var maskPoints = layerMaskProperties[i].pt // Mask Points - object
				var maskPointsAnimated = layerMaskProperties[i].pt.a // Is the mask animated, 0 or 1
				var maskPointsValues = layerMaskProperties[i].pt.k // Is the mask animated, 0 or 1
				
				if (maskPointsAnimated == 0) {
					var pathNodes = maskPointsValues
					forMaskLoop = pathNodes.v
					var maskClosed = maskPointsValues.c // Is the path closed, true or false
					var dPath = 'M'+pathNodes.v[0] // Start Creating the svg path
					for (d = 1; d < forMaskLoop.length; d+=1) {

						dPath += ' C'+ (pathNodes.o[d - 1][0] + pathNodes.v[d - 1][0]) + ',' + (pathNodes.o[d - 1][1] + pathNodes.v[d - 1][1]) +' '+  (pathNodes.i[d][0] + pathNodes.v[d][0]) + ',' + (pathNodes.i[d][1] + pathNodes.v[d][1]) +' '+ (pathNodes.v[d][0])+ ',' + (pathNodes.v[d][1])
					}
					
					if(maskClosed && forMaskLoop.length > 1){
						dPath += ' C'+ (pathNodes.o[d - 1][0] + pathNodes.v[d - 1][0]) + ',' + (pathNodes.o[d - 1][1] + pathNodes.v[d - 1][1]) +' '+  (pathNodes.i[0][0] + pathNodes.v[0][0]) + ',' + (pathNodes.i[0][1] + pathNodes.v[0][1]) +' '+ (pathNodes.v[0][0])+ ',' + (pathNodes.v[0][1])
					}

					buildSVG += '<path d="'+dPath+'" fill="'+layerColor+'"></path>';
				}

				if (maskPointsAnimated == 1) {

					// Function used to restart SVG animations
					maskAnimation(i)

					var pathNodesStart = maskPointsValues[0].s // Grab the starting values
					var pathNodesEnd = maskPointsValues[0].e // Grab the ending values
					var maskClosed = pathNodesStart[0].c // Is the path closed, true or false
					var dPathStart = 'M'+pathNodesStart[0].v[0][0] +','+ pathNodesStart[0].v[0][1]; // Start Creating the svg path
					var dPathEnd = 'M'+pathNodesEnd[0].v[0][0] +','+ pathNodesEnd[0].v[0][1]; // Start Creating the svg path
					var animationDuration = maskPointsValues[1].t / frameRate
					var animationDuration = animationDuration.toFixed(2)
					var animationDelay = maskPointsValues[0].t / frameRate

					keyframeUI += '<div class="wrapTimeline"><div class="timeline">' // Wrap the loop with the timeline
					forMaskLoop = pathNodesStart[0].v
					for (m = 1; m < forMaskLoop.length; m+=1) {
						dPathStart += ' C'+ (pathNodesStart[0].o[m - 1][0] + pathNodesStart[0].v[m - 1][0]) + ',' + (pathNodesStart[0].o[m - 1][1] + pathNodesStart[0].v[m - 1][1]) +' '+  (pathNodesStart[0].i[m][0] + pathNodesStart[0].v[m][0]) + ',' + (pathNodesStart[0].i[m][1] + pathNodesStart[0].v[m][1]) +' '+ (pathNodesStart[0].v[m][0])+ ',' + (pathNodesStart[0].v[m][1])

						dPathEnd += ' C'+ (pathNodesEnd[0].o[m - 1][0] + pathNodesEnd[0].v[m - 1][0]) + ',' + (pathNodesEnd[0].o[m - 1][1] + pathNodesEnd[0].v[m - 1][1]) +' '+  (pathNodesEnd[0].i[m][0] + pathNodesEnd[0].v[m][0]) + ',' + (pathNodesEnd[0].i[m][1] + pathNodesEnd[0].v[m][1]) +' '+ (pathNodesEnd[0].v[m][0])+ ',' + (pathNodesEnd[0].v[m][1])
					}
					if(maskClosed && forMaskLoop.length > 1){
				        dPathStart += ' C'+ (pathNodesStart[0].o[m - 1][0] + pathNodesStart[0].v[m - 1][0]) + ',' + (pathNodesStart[0].o[m - 1][1] + pathNodesStart[0].v[m - 1][1]) +' '+  (pathNodesStart[0].i[0][0] + pathNodesStart[0].v[0][0]) + ',' + (pathNodesStart[0].i[0][1] + pathNodesStart[0].v[0][1]) +' '+ (pathNodesStart[0].v[0][0])+ ',' + (pathNodesStart[0].v[0][1])

				        dPathEnd += ' C'+ (pathNodesEnd[0].o[m - 1][0] + pathNodesEnd[0].v[m - 1][0]) + ',' + (pathNodesEnd[0].o[m - 1][1] + pathNodesEnd[0].v[m - 1][1]) +' '+  (pathNodesEnd[0].i[0][0] + pathNodesEnd[0].v[0][0]) + ',' + (pathNodesEnd[0].i[0][1] + pathNodesEnd[0].v[0][1]) +' '+ (pathNodesEnd[0].v[0][0])+ ',' + (pathNodesEnd[0].v[0][1])
				    }

				    var curveInX = maskPointsValues[0].i.x
					var curveInY = maskPointsValues[0].i.y
					var curveOutX = maskPointsValues[0].o.x
					var curveOutY = maskPointsValues[0].o.y
					var buildBezier = +curveOutX+' '+curveOutY+' '+curveInX+' '+curveInY
					var buildBezierUI = 'cubic-bezier('+buildBezier+')'
					buildSVG += '<path clip-rule="nonzero" d="'+dPathEnd+'" fill="'+maskMode+'"><animate id="animate'+i+'" attributeName="d" begin="'+animationDelay+'s" dur="'+animationDuration+'s" from="'+dPathStart+'" to="'+dPathEnd+'" values="'+dPathStart+'; '+dPathEnd+'" calcMode="spline" keySplines="'+buildBezier+'"/></animate></path>';
					
					// If the there is no "last keyframe" than use animationDuration
					if (layerOutPointSvg == '-Infinity') {
						layerOutPointSvg = animationDuration
					}
					
					// Generate time for From
					var animationDurationKey = animationDuration * 100
					var FromKeyframeTime = (animationDurationKey / layerOutPointSvg).toFixed(2) * 100 // Convert time
					var FromKeyframeTime = parseFloat(FromKeyframeTime.toFixed(2));

					// Generate time for To
					//var animationDelay = animationDelay * 100
					var ToKeyframeTime = (animationDelay / layerOutPointSvg).toFixed(2) * 100 // Convert time
					var ToKeyframeTime = parseFloat(ToKeyframeTime.toFixed(2));

					var positionLeftPX = '0'
					var previousKeyTime = '0'
					var updatedTime = '100'

					// Create To keyframe
					keyframeUI += '<span class="keyframe" style="left:'+ToKeyframeTime+'%" data-attribute="'+animationDelay+'"><span class="timeUI">'+ToKeyframeTime+'%</span></span>'

					keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px">'+maskName+'</span><div class="metaConstants"><span class="durationUI">Duration: '+animationDuration+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'

					// Create From keyframe
					keyframeUI += '<span class="keyframe thisOne" style="left:'+FromKeyframeTime+'%" data-attribute="'+animationDuration+'"><span class="timeUI">'+FromKeyframeTime+'%</span></span>'

					keyframeUI += '<span class="transformProperty">Morph</span></div></div>' // End the UI Wrap
				}
			}
			
			if (layerMaskChild === 1) { // Build out Trkmask and wrap around the element that needs to be masked
				var TrkParent = layers[key - 1].nm;
				var TrkParent = TrkParent.split(' ').join('_'); // Replace spaces with underscores
				var TrkParent = TrkParent.replace('&', '');
				var TrkParent = TrkParent.replace('@', '-');
				var TrkParent = TrkParent.replace('.', '-');
				var TrkParent = TrkParent+'_'+(key - 1);
				var TrkParentColor = layers[key - 1].sc
				var TrkParentHeight = layers[key - 1].sh
				var TrkParentWidth = layers[key - 1].sw

				buildTrk = '<mask id="'+TrkParent+'" mask-type="alpha"><rect width="'+TrkParentWidth+'" height="'+TrkParentHeight+'" fill="'+TrkParentColor+'" class="'+TrkParent+'"></rect></mask>'

				buildSVG += '</mask>'+buildTrk+'<g mask="url(#'+TrkParent+')"><g mask="url(#'+layerName+'-mask)"><rect width="'+layerWidth+'" height="'+layerHeight+'" fill="'+layerColor+'"></rect></g></g></svg>'
			}
			else {
			buildSVG += '</mask><g><rect width="'+layerWidth+'" height="'+layerHeight+'" fill="'+layerColor+'" mask="url(#'+layerName+'-mask)"></rect></g></svg>'
			}
			$('.elements-reset').append(buildSVG);
		}

		
		/***************
			Opacity  
		****************/

		var layerOpacity = layer.ks.o // Opacity Object
		var layerOpacityAnimated = layer.ks.o.a // Is the opacity animated, 0 or 1

		if (layerOpacityAnimated === 1) { // If the Opacity is Animated
			var layerOpacityValue = layer.ks.o.k // Opacity Value
			var layerOpacityStartTime = layer.ks.o.k[0].t // Opacity animation Start Time
			var layerOpacityStartValue = layer.ks.o.k[0].s[0] // Start Keyframe Value
			var layerOpacityEndValue = layer.ks.o.k[0].e[0] // End Keyframe Value
			keyframeStyles += '@keyframes '+layerName+'-opacity {' // Wrap the loop with the keyframe
			keyframeUI += '<div class="wrapTimeline"><div class="timeline">' // Wrap the loop with the timeline
			// Loop through the keyframes
			for (i = 0; i < layerOpacityValue.length; i++) {
			    var keyframeTime = layerOpacityValue[i].t / layerOutPoint // Convert time
			    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
				var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
				var keyframeTime = parseFloat(keyframeTime.toFixed(2));

				// UI Time
				var keyframeTimeUI = layerOpacityValue[i].t / frameRate // Convert time
		    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal

				if (layerOpacityValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					var keyframeValue = layerOpacityValue[previousKeyframe].e
					
				} else {
					var keyframeValue = layerOpacityValue[i].s

					buildBezier = '';
					buildBezierUI = '';
					if (layer.ks.o.x) { // Build out Ease & Wizz Curves
						var easeWizzOutput = layer.ks.o.x
						var matchedCurve;
			            for (var b = 0; b < easeWizzCurves.length; b++) { 
			                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
			                   matchedCurve = easeWizzCurves[b];
			                   var newCurve = cubicBezierOutput(matchedCurve)
			                   buildBezier = 'cubic-bezier'+newCurve;
			                   buildBezierUI += matchedCurve
			                }
			            }
					}
					else { // Build out custom Bezier Curves
						var curveInX = layerOpacityValue[i].i.x
						var curveInY = layerOpacityValue[i].i.y
						var curveOutX = layerOpacityValue[i].o.x
						var curveOutY = layerOpacityValue[i].o.y
						var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
						buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
					} 
				}
				var keyframeValue = keyframeValue / 100
				
				keyframeStyles += keyframeTime+'% ' + '{opacity: '+keyframeValue+';animation-timing-function: '+buildBezier+';}' // Create Keyframe data structure
				
				var previousKeyframe = i - 1
					
				if (previousKeyframe >= 0) {
					var previousKeyTime = layerOpacityValue[i-1].t / layerOutPoint // Convert time
					var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
					var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
					var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

					// Not an awesome way of doing this, but I want to nest the info to the keyframe
					var positionLeftPX = layerOpacityValue[i-1].t / layerOutPoint
					var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
					var positionLeftPX = positionLeftPX * 360;

					var previousKeyTimeUI = layerOpacityValue[i-1].t / frameRate // Convert time
					var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
					var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
					var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2));

					var previouskeyframeValue = layerOpacityValue[i-1].s[0] / 100

					if (previouskeyframeValue === keyframeValue) {

					}
					else {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValue+'<span class="positionToIcon">&#10142;</span>'+keyframeValue+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
				}
				else {
					keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
				}
				keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'	
			} // End for Loop
			keyframeUI += '<span class="transformProperty">Opacity</span></div></div>' // End the UI Wrap
			if (keyframeTime != 100) {
				keyframeStyles += '100% ' + '{opacity: '+keyframeValue+';animation-timing-function: '+buildBezier+';}'
			}
			keyframeStyles += '}'
			var layerOpacityValue = layer.ks.o.k[0].s[0] / 100 // Grab first keyframe value 
			
		}
		else {
			var layerOpacityValue = layer.ks.o.k / 100 // If the Opacity is Static (not animated)
		}


		/***************
			Anchor Point  
		****************/

		var layerAnchor = layer.ks.a // Anchor Point of Object
		var layerAnchorAnimated = layer.ks.a.a // Is the scaling animated, 0 or 1
		
		if (layerAnchorAnimated === 1) { // If the Anchor is Animated
		var layerAnchorValue = layer.ks.a.k
		keyframeStyles += '@keyframes '+layerName+'-anchor {' // Wrap the loop with the keyframe
		keyframeUI += '<div class="wrapTimeline"><div class="timeline">' // Wrap the loop with the timeline
			// Loop through the keyframes
			for (i = 0; i < layerAnchorValue.length; i++) {
			    var keyframeTime = layerAnchorValue[i].t / layerOutPoint // Convert time
			    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
				var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
				var keyframeTime = parseFloat(keyframeTime.toFixed(2));
				// UI Time
				var keyframeTimeUI = layerAnchorValue[i].t / frameRate // Convert time
		    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal

				if (layerAnchorValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					var keyframeValueX = layerAnchorValue[previousKeyframe].e[0]
					var keyframeValueY = layerAnchorValue[previousKeyframe].e[1]
					var keyframeValueZ = layerAnchorValue[previousKeyframe].e[2]

				} else {
					var keyframeValueX = layerAnchorValue[i].s[0]
					var keyframeValueY = layerAnchorValue[i].s[1]
					var keyframeValueZ = layerAnchorValue[i].s[2]
					buildBezier = '';
					buildBezierUI = '';
					if (layer.ks.a.x) { // Build out Ease & Wizz Curves
						var easeWizzOutput = layer.ks.a.x
						var matchedCurve;
			            for (var b = 0; b < easeWizzCurves.length; b++) { 
			                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
			                   matchedCurve = easeWizzCurves[b];
			                   var newCurve = cubicBezierOutput(matchedCurve)
			                   buildBezier = 'cubic-bezier'+newCurve;
			                   buildBezierUI += matchedCurve
			                }
			            }
					}
					else { // Build out custom Bezier Curves
						var curveInX = layerAnchorValue[i].i.x
						var curveInY = layerAnchorValue[i].i.y
						var curveOutX = layerAnchorValue[i].o.x
						var curveOutY = layerAnchorValue[i].o.y
						var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
						// buildBezierUI use to be Custom
						buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
					}
				}
				keyframeStyles += keyframeTime+'% ' + '{transform-origin: '+keyframeValueX+'px '+keyframeValueY+'px '+keyframeValueZ+'px;}' // Create Keyframe data structure
				var previousKeyframe = i - 1
					
				if (previousKeyframe >= 0) {
					var previousKeyTime = layerAnchorValue[i-1].t / layerOutPoint // Convert time
					var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
					var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
					var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

					// Not an awesome way of doing this, but I want to nest the info to the keyframe
					var positionLeftPX = layerAnchorValue[i-1].t / layerOutPoint
					var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
					var positionLeftPX = positionLeftPX * 360;

					var previousKeyTimeUI = layerAnchorValue[i-1].t / frameRate // Convert time
					var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
					var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
					var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2)); // Round the decimal

					var previouskeyframeValueX = layerAnchorValue[i-1].s[0]
					var previouskeyframeValueY = layerAnchorValue[i-1].s[1]
					var previouskeyframeValueZ = layerAnchorValue[i-1].s[2]

					if (previouskeyframeValueX === keyframeValueX && previouskeyframeValueY === keyframeValueY && previouskeyframeValueZ === keyframeValueZ) {

					}
					else {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValueX+' , '+previouskeyframeValueY+' , '+previouskeyframeValueZ+'<span class="positionToIcon">&#10142;</span>'+keyframeValueX+' , '+keyframeValueY+' , '+keyframeValueZ+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
				}
				else {
					keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
				}
				keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'	
			}

			keyframeUI += '<span class="transformProperty">Origin</span></div></div>' // End the UI Wrap
			keyframeStyles += '}'
			var layerAnchorValueX = layerAnchorValue[0].s[0]
			var layerAnchorValueY = layerAnchorValue[0].s[1]
			var layerAnchorValueZ = layerAnchorValue[0].s[2]
			var layerAnchorCompile = layerAnchorValueX +'px '+ layerAnchorValueY +'px '+ layerAnchorValueZ+'px'
		}
		else {
			// If the Anchor Point is Static (not animated)
			var layerAnchorValueX = layer.ks.a.k[0]
			var layerAnchorValueY = layer.ks.a.k[1]
			var layerAnchorValueZ = layer.ks.a.k[2]
			var layerAnchorCompile = layerAnchorValueX +'px '+ layerAnchorValueY +'px '+ layerAnchorValueZ+'px'
		}



		/***************
			Position  
		****************/

		var layerPosition = layer.ks.p // Position of Object
		var layerPositionSplit = layer.ks.p.s // Is the X & Y Positions split
		var layerPositionAnimated = layer.ks.p.a // Is the position animated, 0 or 1
		 
		if (layerPositionSplit === true) {

			// If layer position X is separated
			var layerPositionX = layer.ks.p.x
			var layerPositionXAnimated = layer.ks.p.x.a
			
			if (layerPositionXAnimated === 1) {
				var layerPositionValue = layer.ks.p.x.k
				keyframeStyles += '@keyframes '+layerName+'-positionX {' // Wrap the loop with the keyframe 
				keyframeUI += '<div class="wrapTimeline"><div class="timeline">'
				
				for (i = 0; i < layerPositionValue.length; i++) {
					var keyframeTime = layerPositionValue[i].t / layerOutPoint // Convert time
				    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
					var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
					var keyframeTime = parseFloat(keyframeTime.toFixed(2));

					// UI Time
					var keyframeTimeUI = layerPositionValue[i].t / frameRate // Convert time
			    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal
			    	var keyframeTimeUI = keyframeTimeUI;

					if (layerPositionValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
						var previousKeyframe = i - 1
						// Relative CSS Positioning
						var firstKeyframeValueX = layerPositionValue[0].s[0] - layerAnchorValueX
						if (firstKeyframeValueX >= (canvasWidth / 2)) {
							var keyframeValueX = layerPositionValue[previousKeyframe].e[0] - layerAnchorValueX
							var keyframeValueX = canvasWidth - keyframeValueX - layerWidth;
							var keyframeValueXUI = keyframeValueX+'px'
							var keyframeValueX = 'right: '+keyframeValueX+'px'
							
						}
						else {
							var keyframeValueXUI = (layerPositionValue[previousKeyframe].e[0] - layerAnchorValueX)+'px'
							var keyframeValueX = 'left: '+(layerPositionValue[previousKeyframe].e[0] - layerAnchorValueX)+'px'
						}
					} else {
						
						// Relative CSS Positioning
						var firstKeyframeValueX = layerPositionValue[0].s[0] - layerAnchorValueX
						// If the object is beyond half the canvas start from right
						if (firstKeyframeValueX >= (canvasWidth / 2)) {
							var keyframeValueX = layerPositionValue[i].s[0] - layerAnchorValueX
							var keyframeValueX = canvasWidth - keyframeValueX - layerWidth;
							var keyframeValueXUI = keyframeValueX+'px'
							var keyframeValueX = 'right: '+keyframeValueX+'px'
						}
						else {
							var keyframeValueXUI = (layerPositionValue[i].s[0] - layerAnchorValueX)+'px'
							var keyframeValueX = 'left: '+(layerPositionValue[i].s[0] - layerAnchorValueX)+'px'
							var keyframeValueXTrk = (layerPositionValue[i].s[0] - layerAnchorValueX)+'px'
							
						}
						
						// Build out the Bezier Curves
						buildBezier = '';
						buildBezierUI = '';
						if (layer.ks.p.x.x) { // Build out Ease & Wizz Curves
							var easeWizzOutput = layer.ks.p.x.x
							var matchedCurve;
				            for (var b = 0; b < easeWizzCurves.length; b++) { 
				                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
				                   matchedCurve = easeWizzCurves[b];
				                   var newCurve = cubicBezierOutput(matchedCurve)
				                   buildBezier = 'cubic-bezier'+newCurve;
				                   buildBezierUI += matchedCurve
				                }
				            }
						}
						else { // Build out custom Bezier Curves
							var curveInX = layerPositionValue[i].i.x
							var curveInY = layerPositionValue[i].i.y
							var curveOutX = layerPositionValue[i].o.x
							var curveOutY = layerPositionValue[i].o.y
							var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
							buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
						}
					}
					if (layerMaskParent === 1) {
						keyframeStyles += keyframeTime+'% ' + '{transform: translateX('+keyframeValueXTrk+');animation-timing-function:'+buildBezier+';}' // Create Keyframe data structure
					}
					else {
						keyframeStyles += keyframeTime+'% ' + '{'+keyframeValueX+';animation-timing-function: '+buildBezier+';}' // Create Keyframe data structure
						var previousKeyframe = i - 1
						
						if (previousKeyframe >= 0) {
							var previousKeyTime = layerPositionValue[i-1].t / layerOutPoint // Convert time
							var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
							var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
							var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

							// Not an awesome way of doing this, but I want to nest the info to the keyframe
							var positionLeftPX = layerPositionValue[i-1].t / layerOutPoint
							var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
							var positionLeftPX = positionLeftPX * 360;

							var previousKeyTimeUI = layerPositionValue[i-1].t / frameRate // Convert time
							var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
							var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
							var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2)); // Round the decimal

							// More relative CSS position
							if (firstKeyframeValueX >= (canvasWidth / 2)) {
								var previouskeyframeValueX = layerPositionValue[i-1].s[0] - layerAnchorValueX // Previous keyframe value Position X
								var previouskeyframeValueX = canvasWidth - previouskeyframeValueX - layerWidth;
								var previouskeyframeValueX = 'right: '+previouskeyframeValueX+'px'
							}
							else {
								var previouskeyframeValueX = 'left: '+(layerPositionValue[i-1].s[0] - layerAnchorValueX)+'px' // Previous keyframe value Position X
							}

							if (previouskeyframeValueX === keyframeValueX) {

							}
							else {
								keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValueX+'<span class="positionToIcon">&#10142;</span>'+keyframeValueXUI+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
							}
						}
						else {
							keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
						}
						keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'
					}
				}
				keyframeUI += '<span class="transformProperty">Position X</span></div></div>'
				if (keyframeTime != 100) {
					keyframeStyles += '100% ' + '{'+keyframeValueX+';animation-timing-function: '+buildBezier+';}'
				}
				keyframeStyles += '}'
			}
			else {
				var layerPositionValueX = 'left: '+(layer.ks.p.x.k - layerAnchorValueX)+'px'
			}

			// If layer position Y is separated
			var layerPositionY = layer.ks.p.y
			var layerPositionYAnimated = layer.ks.p.y.a
			if (layerPositionYAnimated === 1) {
				var layerPositionValue = layer.ks.p.y.k
				keyframeStyles += '@keyframes '+layerName+'-positionY {' // Wrap the loop with the keyframe keyframe structure
				keyframeUI += '<div class="wrapTimeline"><div class="timeline">'
				for (i = 0; i < layerPositionValue.length; i++) {
					var keyframeTime = layerPositionValue[i].t / layerOutPoint // Convert time
				    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
					var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
					var keyframeTime = parseFloat(keyframeTime.toFixed(2));

					// UI Time
					var keyframeTimeUI = layerPositionValue[i].t / frameRate // Convert time
			    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal
			    	var keyframeTimeUI = keyframeTimeUI;

					if (layerPositionValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
						var previousKeyframe = i - 1
						var keyframeValueY = layerPositionValue[previousKeyframe].e[0] - layerAnchorValueY
					} else {
						var keyframeValueY = layerPositionValue[i].s[0] - layerAnchorValueY	

						// Build out the Bezier Curves
						buildBezier = '';
						buildBezierUI = '';
						if (layer.ks.p.x.x) { // Build out Ease & Wizz Curves
							var easeWizzOutput = layer.ks.p.x.x
							var matchedCurve;
				            for (var b = 0; b < easeWizzCurves.length; b++) { 
				                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
				                   matchedCurve = easeWizzCurves[b];
				                   var newCurve = cubicBezierOutput(matchedCurve)
				                   buildBezier = 'cubic-bezier'+newCurve;
				                   buildBezierUI += matchedCurve
				                }
				            }
						}
						else { // Build out custom Bezier Curves
							var curveInX = layerPositionValue[i].i.x
							var curveInY = layerPositionValue[i].i.y
							var curveOutX = layerPositionValue[i].o.x
							var curveOutY = layerPositionValue[i].o.y
							var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
							buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
						}
					}

					if (layerMaskParent === 1) {
						keyframeStyles += keyframeTime+'% ' + '{transform: translateY('+keyframeValueY+'px);animation-timing-function:'+buildBezier+';}' // Create Keyframe data structure
					}
					else {
						keyframeStyles += keyframeTime+'% ' + '{top:'+keyframeValueY+'px;animation-timing-function:'+buildBezier+';}' // Create Keyframe data structure
						var previousKeyframe = i - 1
						if (previousKeyframe >= 0) {
							var previousKeyTime = layerPositionValue[i-1].t / layerOutPoint // Convert time
							var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
							var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
							var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

							// Not an awesome way of doing this, but I want to nest the info to the keyframe
							var positionLeftPX = layerPositionValue[i-1].t / layerOutPoint
							var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
							var positionLeftPX = positionLeftPX * 360;

							var previousKeyTimeUI = layerPositionValue[i-1].t / frameRate // Convert time
							var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
							var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
							var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2)); // Round the decimal

							var previouskeyframeValueY = layerPositionValue[i-1].s[0] - layerAnchorValueY // Previous keyframe value Position Y
							
							if (previouskeyframeValueY === keyframeValueY) {

							}
							else {
								keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">top: '+previouskeyframeValueY+'px<span class="positionToIcon">&#10142;</span>'+keyframeValueY+'px</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
							}
						}
						else {
							keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
						}
						keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'
					}
				}
				keyframeUI += '<span class="transformProperty">Position Y</span></div></div>'
				if (keyframeTime != 100) {
					keyframeStyles += '100% ' + '{top:'+keyframeValueY+'px;animation-timing-function:'+buildBezier+';}'
				}
				keyframeStyles += '}'
			}
			else {
				var firstKeyframeValueY = layer.ks.p.y.k - layerAnchorValueY
				if (firstKeyframeValueY >= (canvasHeight / 2)) {
					var layerPositionValueY = layer.ks.p.y.k - layerAnchorValueY
					var layerPositionValueY = canvasHeight - layerPositionValueY - layerHeight;
					var layerPositionValueY = 'bottom: '+layerPositionValueY+'px'
				}
				else {
					var layerPositionValueY = 'top: '+(layer.ks.p.y.k - layerAnchorValueY)+'px'
				}
			}

		}
		else if (layerPositionAnimated === 1) { // If the Position is Animated
			var firstKeyframeValueX = layer.ks.p.k[0].s[0] - layerAnchorValueX // X Position of Object minus Anchor Point
			if (firstKeyframeValueX >= (canvasWidth / 2)) {
				var layerPositionValueX = layer.ks.p.k[0].s[0] - layerAnchorValueX
				var layerPositionValueX = canvasWidth - layerPositionValueX - layerWidth;
				var layerPositionValueX = 'right: '+layerPositionValueX+'px'
			}
			else {
				var layerPositionValueX = 'left: '+(layer.ks.p.k[0].s[0] - layerAnchorValueX)+'px'
			}

			var firstKeyframeValueY = layer.ks.p.k[0].s[1] - layerAnchorValueY // Y Position of Object minus Anchor Point
			if (firstKeyframeValueY >= (canvasHeight / 2)) {
				var layerPositionValueY = layer.ks.p.k[0].s[1] - layerAnchorValueY
				var layerPositionValueY = canvasHeight - layerPositionValueY - layerHeight;
				var layerPositionValueY = 'bottom: '+layerPositionValueY+'px'
			}
			else {
				var layerPositionValueY = 'top: '+(layer.ks.p.k[0].s[1] - layerAnchorValueY)+'px'
			}

			var layerPositionValue = layer.ks.p.k // Position of Object
			keyframeStyles += '@keyframes '+layerName+'-position {' // Wrap the loop with the keyframe 
			keyframeUI += '<div class="wrapTimeline"><div class="timeline">' // Wrap the loop with the timeline
			for (i = 0; i < layerPositionValue.length; i++) {
				var keyframeTime = layerPositionValue[i].t / layerOutPoint // Convert time
			    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
				var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
				var keyframeTime = parseFloat(keyframeTime.toFixed(2));
				// UI Time
				var keyframeTimeUI = layerPositionValue[i].t / frameRate // Convert time
		    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal
		    	var keyframeTimeUI = keyframeTimeUI;

				if (layerPositionValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					
					// Relative CSS Positioning for X
					var firstKeyframeValueX = layerPositionValue[0].s[0] - layerAnchorValueX
					// If the object is beyond half the canvas start from right
					if (firstKeyframeValueX >= (canvasWidth / 2)) {
						var keyframeValueX = layerPositionValue[previousKeyframe].e[0] - layerAnchorValueX
						var keyframeValueX = canvasWidth - keyframeValueX - layerWidth;
						var keyframeValueXUI = keyframeValueX+'px'
						var keyframeValueX = 'right: '+keyframeValueX+'px'
					}
					else {
						var keyframeValueXUI = (layerPositionValue[previousKeyframe].e[0] - layerAnchorValueX)+'px'
						var keyframeValueX = 'left: '+(layerPositionValue[previousKeyframe].e[0] - layerAnchorValueX)+'px'
						var keyframeValueXTrk = (layerPositionValue[previousKeyframe].e[0] - layerAnchorValueX)+'px'
					}

					// Relative CSS Positioning for Y
					var firstKeyframeValueY = layerPositionValue[0].s[1] - layerAnchorValueY
					// If the object is beyond half the canvas start from right
					if (firstKeyframeValueY >= (canvasHeight / 2)) {
						var keyframeValueY = layerPositionValue[previousKeyframe].e[1] - layerAnchorValueY
						var keyframeValueY = canvasHeight - keyframeValueY - layerHeight;
						var keyframeValueYUI = keyframeValueY+'px'
						var keyframeValueY = 'bottom: '+keyframeValueY+'px'
					}
					else {
						var keyframeValueYUI = 'top: '+(layerPositionValue[previousKeyframe].e[1] - layerAnchorValueY)+'px'
						var keyframeValueY = 'top: '+(layerPositionValue[previousKeyframe].e[1] - layerAnchorValueY)+'px'
						var keyframeValueYTrk = (layerPositionValue[previousKeyframe].e[1] - layerAnchorValueY)+'px'
					}

				} else {
					// Relative CSS Positioning for X
					var firstKeyframeValueX = layerPositionValue[0].s[0] - layerAnchorValueX
					// If the object is beyond half the canvas start from right
					if (firstKeyframeValueX >= (canvasWidth / 2)) {
						var keyframeValueX = layerPositionValue[i].s[0] - layerAnchorValueX
						var keyframeValueX = canvasWidth - keyframeValueX - layerWidth;
						var keyframeValueXUI = keyframeValueX+'px'
						var keyframeValueX = 'right: '+keyframeValueX+'px'
					}
					else {
						var keyframeValueXUI = (layerPositionValue[i].s[0] - layerAnchorValueX)+'px'
						var keyframeValueX = 'left: '+(layerPositionValue[i].s[0] - layerAnchorValueX)+'px'
						var keyframeValueXTrk = (layerPositionValue[i].s[0] - layerAnchorValueX)+'px'
					}

					// Relative CSS Positioning for Y
					var firstKeyframeValueY = layerPositionValue[0].s[1] - layerAnchorValueY
					// If the object is beyond half the canvas start from right
					if (firstKeyframeValueY >= (canvasHeight / 2)) {
						var keyframeValueY = layerPositionValue[i].s[1] - layerAnchorValueY
						var keyframeValueY = canvasHeight - keyframeValueY - layerHeight;
						var keyframeValueYUI = keyframeValueY+'px'
						var keyframeValueY = 'bottom: '+keyframeValueY+'px'
					}
					else {
						var keyframeValueYUI = (layerPositionValue[i].s[1] - layerAnchorValueY)+'px'
						var keyframeValueY = 'top: '+(layerPositionValue[i].s[1] - layerAnchorValueY)+'px'
						var keyframeValueYTrk = (layerPositionValue[i].s[1] - layerAnchorValueY)+'px'
					}

					buildBezier = '';
					buildBezierUI = '';
					if (layer.ks.p.x) { // Build out Ease & Wizz Curves
						var easeWizzOutput = layer.ks.p.x
						var matchedCurve;
			            for (var b = 0; b < easeWizzCurves.length; b++) { 
			                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
			                   matchedCurve = easeWizzCurves[b];
			                   var newCurve = cubicBezierOutput(matchedCurve)
			                   buildBezier = 'cubic-bezier'+newCurve;
			                   buildBezierUI += matchedCurve
			                }
			            }
					}
					else { // Build out custom Bezier Curves
						var curveInX = layerPositionValue[i].i.x
						var curveInY = layerPositionValue[i].i.y
						var curveOutX = layerPositionValue[i].o.x
						var curveOutY = layerPositionValue[i].o.y
						var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
						buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
					}
				}
				
				if (layerMaskParent === 1) {
					keyframeStyles += keyframeTime+'% ' + '{transform: translateX('+keyframeValueXTrk+') translateY('+keyframeValueYTrk+');animation-timing-function: '+buildBezier+';}' // Create Keyframe data structure
				}
				else {
					keyframeStyles += keyframeTime+'% ' + '{'+keyframeValueX+';'+keyframeValueY+';animation-timing-function: '+buildBezier+';}' // Create Keyframe data structure
				}
				var previousKeyframe = i - 1
				
				if (previousKeyframe >= 0) {
					var previousKeyTime = layerPositionValue[i-1].t / layerOutPoint // Convert time
					var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
					var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
					var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

					// Not an awesome way of doing this, but I want to nest the info to the keyframe
					var positionLeftPX = layerPositionValue[i-1].t / layerOutPoint
					var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
					var positionLeftPX = positionLeftPX * 360;

					var previousKeyTimeUI = layerPositionValue[i-1].t / frameRate // Convert time
					var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
					var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
					var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2)); // Round the decimal

					// More relative CSS position X
					if (firstKeyframeValueX >= (canvasWidth / 2)) {
						var previouskeyframeValueX = layerPositionValue[i-1].s[0] - layerAnchorValueX // Previous keyframe value Position X
						var previouskeyframeValueX = canvasWidth - previouskeyframeValueX - layerWidth;
						var previouskeyframeValueX = 'right: '+previouskeyframeValueX+'px'
					}
					else {
						var previouskeyframeValueX = 'left: '+(layerPositionValue[i-1].s[0] - layerAnchorValueX)+'px' // Previous keyframe value Position X
					}

					// More relative CSS position Y
					if (firstKeyframeValueY >= (canvasHeight / 2)) {
						var previouskeyframeValueY = layerPositionValue[i-1].s[1] - layerAnchorValueY // Previous keyframe value Position Y
						var previouskeyframeValueY = canvasHeight - previouskeyframeValueY - layerHeight;
						var previouskeyframeValueY = 'bottom: '+previouskeyframeValueY+'px'
					}
					else {
						var previouskeyframeValueY = 'top: '+(layerPositionValue[i-1].s[1] - layerAnchorValueY)+'px' // Previous keyframe value Position Y
					}

					// If the values are the same, than it's not really animated...
					if (previouskeyframeValueX === keyframeValueX && previouskeyframeValueY === keyframeValueY) {
						
					}
					// If the X position is the same, don't include it
					else if (previouskeyframeValueX === keyframeValueX) {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValueY+'<span class="positionToIcon">&#10142;</span>'+keyframeValueYUI+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
					// If the Y position is the same, don't include it
					else if (previouskeyframeValueY === keyframeValueY) {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValueX+'<span class="positionToIcon">&#10142;</span>'+keyframeValueXUI+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
					else {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValueX+' , '+previouskeyframeValueY+'<span class="positionToIcon">&#10142;</span>'+keyframeValueXUI+' , '+keyframeValueYUI+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
				}
				else {
					keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
				}
				keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'
			}
			keyframeUI += '<span class="transformProperty">Position</span></div></div>'
			if (keyframeTime != 100) {
				keyframeStyles += '100% ' + '{'+keyframeValueX+';'+keyframeValueY+';animation-timing-function: '+buildBezier+';}'
			}
			keyframeStyles += '}'
		}
		else {
			
			/*****

				STATIC POSITIONING: Some conditional statements to see if it should use left/right & top/bottom

			*****/

			// Adjust the CSS right/left top/bottom based on these factors
			if (shapePositionXAdjust != undefined) {
				var firstKeyframeValueX = (layer.ks.p.k[0] - layerAnchorValueX) + shapePositionXAdjust
			}
			else {
				var firstKeyframeValueX = (layer.ks.p.k[0] - layerAnchorValueX)
			}
			
			if (firstKeyframeValueX >= (canvasWidth / 2)) {
				if (layerType === 4) {
					var layerPositionValueX = (layer.ks.p.k[0] - layerAnchorValueX) + shapePositionXAdjust - (shapeWidth / 2);
					var layerPositionValueX = layerPositionValueX.toFixed(0)
				}
				else {
					var layerPositionValueX = (layer.ks.p.k[0] - layerAnchorValueX); 
				}
				if (layerType === 5) {
					var layerWidth = '';
				}
				var layerPositionValueX = canvasWidth - layerPositionValueX - layerWidth;
				var layerPositionValueX = layerPositionValueX.toFixed(0)
				var layerPositionValueX = 'right: '+layerPositionValueX+'px'
			}
			else {
				if (layerType === 4) {
					var layerPositionValueX = ((layer.ks.p.k[0] - layerAnchorValueX) + shapePositionXAdjust - (shapeWidth / 2))
					var layerPositionValueX = layerPositionValueX.toFixed(0)
					var layerPositionValueX = 'left: '+layerPositionValueX+'px'
				}
				else {
					var layerPositionValueX = 'left: '+(layer.ks.p.k[0] - layerAnchorValueX)+'px'
				}
			}
			// More relative CSS position Y
			if (shapePositionYAdjust != undefined) {
				var firstKeyframeValueY = (layer.ks.p.k[1] - layerAnchorValueY) + shapePositionYAdjust
			}
			else {
				var firstKeyframeValueY = (layer.ks.p.k[1] - layerAnchorValueY)
			}
			
			if (firstKeyframeValueY >= (canvasHeight / 2)) {
				if (layerType === 4) {
					var layerPositionValueY = (layer.ks.p.k[1] - layerAnchorValueY) + shapePositionYAdjust - (shapeHeight / 2);
					var layerPositionValueY = layerPositionValueY.toFixed(0)
				}
				else {
					var layerPositionValueY = layer.ks.p.k[1] - layerAnchorValueY
				}
				if (layerType === 5) {
					var layerHeight = '';
				}
				var layerPositionValueY = (canvasHeight - layerPositionValueY) - layerHeight;
				var layerPositionValueY = layerPositionValueY.toFixed(0)
				var layerPositionValueY = 'bottom: '+layerPositionValueY+'px'
			}
			else {
				if (layerType === 4) {
					var layerPositionValueY = ((layer.ks.p.k[1] - layerAnchorValueY) + shapePositionYAdjust - (shapeHeight / 2))
					var layerPositionValueY = layerPositionValueY.toFixed(0)
					var layerPositionValueY = 'top: '+layerPositionValueY+'px'
				}
				else {
					var layerPositionValueY = 'top: '+(layer.ks.p.k[1] - layerAnchorValueY)+'px'
				}
			}
		}
 


		/***************
			Transform: Rotation  & Scale
		****************/

		// Rotation
		var layerRotation = layer.ks.r // Rotation of Object
		var layerRotationAnimated = layer.ks.r.a // Is the rotation animated, 0 or 1
		// Scale
		var layerScale = layer.ks.s // Scale of Object
		var layerScaleAnimated = layer.ks.s.a // Is the scaling animated, 0 or 1

		staticTransform = ''

		if (layerRotationAnimated === 0 && layerScaleAnimated === 0) { // Static Rotation
			staticTransform += 'rotate('+layer.ks.r.k+'deg) '
			var layerScaleValueX = layer.ks.s.k[0] / 100
			var layerScaleValueY = layer.ks.s.k[1] / 100
			var layerScaleValueZ = layer.ks.s.k[2] / 100
			staticTransform += 'scale3d('+layerScaleValueX+','+layerScaleValueY+','+layerScaleValueZ+')'
		}

		if (layerRotationAnimated === 1 && layerScaleAnimated === 0) { // If the Rotation is Animated
			staticTransform += 'rotate('+layer.ks.r.k[0].s[0]+'deg) '
			var layerScaleValueX = layer.ks.s.k[0] / 100
			var layerScaleValueY = layer.ks.s.k[1] / 100
			var layerScaleValueZ = layer.ks.s.k[2] / 100
			staticTransform += 'scale3d('+layerScaleValueX+','+layerScaleValueY+','+layerScaleValueZ+')'
		}

		if (layerRotationAnimated === 1 && layerScaleAnimated === 0) { // If the Rotation is Animated
			var layerRotationValue = layer.ks.r.k
			var layerRotationStartValue = layer.ks.r.k[0].s[0] // Start Keyframe Value
			var layerRotationEndValue = layer.ks.r.k[0].e[0] // End Keyframe Value
			
			keyframeStyles += '@keyframes '+layerName+'-rotation {' // Wrap the loop with the keyframe 
			keyframeUI += '<div class="wrapTimeline"><div class="timeline">' // Wrap the loop with the timeline

			// Loop through the keyframes
			for (i = 0; i < layerRotationValue.length; i++) {
			    var keyframeTime = layerRotationValue[i].t / layerOutPoint // Convert time
			    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
				var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
				var keyframeTime = parseFloat(keyframeTime.toFixed(2));
				// UI Time
				var keyframeTimeUI = layerRotationValue[i].t / frameRate // Convert time
		    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal

				if (layerRotationValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					var keyframeValue = layerRotationValue[previousKeyframe].e

				} else {
					var keyframeValue = layerRotationValue[i].s
					
					buildBezier = '';
					buildBezierUI = '';
					if (layer.ks.r.x) { // Build out Ease & Wizz Curves
						var easeWizzOutput = layer.ks.r.x
						var matchedCurve;
			            for (var b = 0; b < easeWizzCurves.length; b++) { 
			                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
			                   matchedCurve = easeWizzCurves[b];
			                   var newCurve = cubicBezierOutput(matchedCurve)
			                   buildBezier = 'cubic-bezier'+newCurve;
			                   buildBezierUI += matchedCurve
			                }
			            }
					}
					else { // Build out custom Bezier Curves
						var curveInX = layerRotationValue[i].i.x
						var curveInY = layerRotationValue[i].i.y
						var curveOutX = layerRotationValue[i].o.x
						var curveOutY = layerRotationValue[i].o.y
						var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
						buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
					}

				}
				keyframeStyles += keyframeTime+'% ' + '{transform: rotate('+keyframeValue+'deg);animation-timing-function: '+buildBezier+';}' // Create Keyframe data structure
				var previousKeyframe = i - 1
					
				if (previousKeyframe >= 0) {
					var previousKeyTime = layerRotationValue[i-1].t / layerOutPoint // Convert time
					var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
					var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
					var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

					// Not an awesome way of doing this, but I want to nest the info to the keyframe
					var positionLeftPX = layerRotationValue[i-1].t / layerOutPoint
					var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
					var positionLeftPX = positionLeftPX * 360;

					var previousKeyTimeUI = layerRotationValue[i-1].t / frameRate // Convert time
					var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
					var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
					var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2)); // Round the decimal

					var previouskeyframeValue = layerRotationValue[i-1].s[0]

					if (previouskeyframeValue === keyframeValue) {

					}
					else {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValue+'<span class="positionToIcon">&#10142;</span>'+keyframeValue+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
				}
				else {
					keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
				}
				keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'	
			}

			keyframeUI += '<span class="transformProperty">Rotation</span></div></div>' // End the UI Wrap
			if (keyframeTime != 100) {
				keyframeStyles += '100% ' + '{transform: rotate('+keyframeValue+'deg);animation-timing-function: '+buildBezier+';}'
			}
			keyframeStyles += '}'
		}

		if (layerRotationAnimated === 0 && layerScaleAnimated === 1) { // If the Rotation is Animated
			staticTransform += 'rotate('+layer.ks.r.k+'deg) '
			var layerScaleValueX = layer.ks.s.k[0].s[0] / 100
			var layerScaleValueY = layer.ks.s.k[0].s[1] / 100
			var layerScaleValueZ = layer.ks.s.k[0].s[2] / 100
			staticTransform += 'scale3d('+layerScaleValueX+','+layerScaleValueY+','+layerScaleValueZ+')'
		}

		if (layerRotationAnimated === 0 && layerScaleAnimated === 1) { // If the Rotation is Animated
			var layerScaleValue = layer.ks.s.k
			keyframeStyles += '@keyframes '+layerName+'-scale {' // Wrap the loop with the keyframe
			keyframeUI += '<div class="wrapTimeline"><div class="timeline">' // Wrap the loop with the timeline
			for (i = 0; i < layerScaleValue.length; i++) {
				var keyframeTime = layerScaleValue[i].t / layerOutPoint // Convert time
			    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
				var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
				var keyframeTime = parseFloat(keyframeTime.toFixed(2));

				var keyframeTimeUI = layerScaleValue[i].t / frameRate // Convert time
		    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal

				if (layerScaleValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					var keyframeValueX = layerScaleValue[previousKeyframe].e[0] / 100
					var keyframeValueY = layerScaleValue[previousKeyframe].e[1] / 100
					var keyframeValueZ = layerScaleValue[previousKeyframe].e[2] / 100

					// Initial State of the Animationm
					var layerScaleValueX = layerScaleValue[previousKeyframe].e[0] / 100
					var layerScaleValueY = layerScaleValue[previousKeyframe].e[1] / 100
					var layerScaleValueZ = layerScaleValue[previousKeyframe].e[2] / 100
				} else {
					var keyframeValueX = layerScaleValue[i].s[0] / 100
					var keyframeValueY = layerScaleValue[i].s[1] / 100
					var keyframeValueZ = layerScaleValue[i].s[2] / 100

					buildBezier = '';
					buildBezierUI = '';
					
					if (layer.ks.s.x) { // Build out Ease & Wizz Curves
						var easeWizzOutput = layer.ks.s.x
						var matchedCurve;
			            for (var b = 0; b < easeWizzCurves.length; b++) { 
			                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
			                   matchedCurve = easeWizzCurves[b];
			                   var newCurve = cubicBezierOutput(matchedCurve)
			                   buildBezier = 'cubic-bezier'+newCurve;
			                   buildBezierUI += matchedCurve
			                }
			            }
					}
					else { // Build out custom Bezier Curves
						var curveInX = layerScaleValue[i].i.x
						var curveInY = layerScaleValue[i].i.y
						var curveOutX = layerScaleValue[i].o.x
						var curveOutY = layerScaleValue[i].o.y
						//var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
						//buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
						var buildBezier = 'cubic-bezier('+curveOutX+')'
						buildBezierUI += 'cubic-bezier('+curveOutX+')';
					}
				}

				keyframeValueX = keyframeValueX.toFixed(2);
				keyframeValueY = keyframeValueY.toFixed(2);
				keyframeValueZ = keyframeValueZ.toFixed(2);
				
				keyframeStyles += keyframeTime+'% ' + '{transform: scale3d('+keyframeValueX+','+keyframeValueY+','+keyframeValueZ+');animation-timing-function:'+buildBezier+';}' // Create Keyframe data structure
				var previousKeyframe = i - 1
					
				if (previousKeyframe >= 0) {
					var previousKeyTime = layerScaleValue[i-1].t / layerOutPoint // Convert time
					var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
					var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
					var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

					// Not an awesome way of doing this, but I want to nest the info to the keyframe
					var positionLeftPX = layerScaleValue[i-1].t / layerOutPoint
					var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
					var positionLeftPX = positionLeftPX * 360;

					var previousKeyTimeUI = layerScaleValue[i-1].t / frameRate // Convert time
					var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
					var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
					var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2)); // Round the decimal

					var previouskeyframeValueX = layerScaleValue[i-1].s[0] / 100
					var previouskeyframeValueY = layerScaleValue[i-1].s[1] / 100
					var previouskeyframeValueZ = layerScaleValue[i-1].s[2] / 100

					if (previouskeyframeValueX === keyframeValueX && previouskeyframeValueY === keyframeValueY && previouskeyframeValueZ === keyframeValueZ) {

					}
					else {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValueX+' , '+previouskeyframeValueY+' , '+previouskeyframeValueX+'<span class="positionToIcon">&#10142;</span>'+keyframeValueX+' , '+keyframeValueY+' , '+keyframeValueZ+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
				}
				else {
					keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
				}
				keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'	
			}
			keyframeUI += '<span class="transformProperty">Scale</span></div></div>' // End the UI Wrap
			if (keyframeTime != 100) {
				keyframeStyles += '100% ' + '{transform: scale3d('+keyframeValueX+','+keyframeValueY+','+keyframeValueZ+');animation-timing-function:'+buildBezier+';}'
			}
			keyframeStyles += '}'	
		}

		if (layerRotationAnimated === 1 && layerScaleAnimated === 1) { // If both Scale & Rotation are animated
			staticTransform += 'rotate('+layer.ks.r.k[0].s[0]+'deg) '
			var layerScaleValueX = layer.ks.s.k[0].s[0] / 100
			var layerScaleValueY = layer.ks.s.k[0].s[1] / 100
			var layerScaleValueZ = layer.ks.s.k[0].s[2] / 100
			staticTransform += 'scale3d('+layerScaleValueX+','+layerScaleValueY+','+layerScaleValueZ+')'

			keyframeStyles += '@keyframes '+layerName+'-transform {' // Wrap the loop with the keyframe

			
			var layerScaleValue = layer.ks.s.k
			var layerRotationValue = layer.ks.r.k
			

			// Will need to have this support if the length is large on rotation?
			for (i = 0; i < layerScaleValue.length; i++) {
				var scaleTimes = layerScaleValue[i].t / layerOutPoint // Convert time
			    var scaleTimes = scaleTimes.toFixed(2); // Round to 2nd decimal
				var scaleTimes = scaleTimes * 100 // Convert to percentage for keyframe

				var rotationTimes = layerRotationValue[i].t / layerOutPoint // Convert time
			    var rotationTimes = rotationTimes.toFixed(2); // Round to 2nd decimal
				var rotationTimes = rotationTimes * 100 // Convert to percentage for keyframe

				if (layerRotationValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					var keyframeValueRotate = layerRotationValue[previousKeyframe].e
				} else {
					var keyframeValueRotate = layerRotationValue[i].s			
				}
				if (layerScaleValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					var keyframeValueX = layerScaleValue[previousKeyframe].e[0] / 100
					var keyframeValueY = layerScaleValue[previousKeyframe].e[1] / 100
					var keyframeValueZ = layerScaleValue[previousKeyframe].e[2] / 100

					// Initial State of the Animationm
					var layerScaleValueX = layerScaleValue[previousKeyframe].e[0] / 100
					var layerScaleValueY = layerScaleValue[previousKeyframe].e[1] / 100
					var layerScaleValueZ = layerScaleValue[previousKeyframe].e[2] / 100

					var scaleTimes = layerScaleValue[i].t / layerOutPoint // Convert time
				    var scaleTimes = scaleTimes.toFixed(2); // Round to 2nd decimal
					var scaleTimes = scaleTimes * 100 // Convert to percentage for keyframe

				} else {
					var keyframeValueX = layerScaleValue[i].s[0] / 100
					var keyframeValueY = layerScaleValue[i].s[1] / 100
					var keyframeValueZ = layerScaleValue[i].s[2] / 100
				}

				if (scaleTimes === rotationTimes) {
					keyframeTime = scaleTimes
					keyframeStyles += keyframeTime+'% ' + '{transform: rotate('+keyframeValueRotate+'deg) scale3d('+keyframeValueX+','+keyframeValueY+','+keyframeValueZ+');}'
				}
				else {
					keyframeStyles += scaleTimes+'% ' + '{transform: rotate('+keyframeValueRotate+'deg) scale3d('+keyframeValueX+','+keyframeValueY+','+keyframeValueZ+');}'
					keyframeStyles += rotationTimes+'% ' + '{transform: rotate('+keyframeValueRotate+'deg) scale3d('+keyframeValueX+','+keyframeValueY+','+keyframeValueZ+');}'
				}		
			}
			if (keyframeTime != 100) {
				console.log('need to support multiples')
			}
			keyframeStyles += '}'

			/****** 
			UI FOR ROTATION 
			*********/
			keyframeUI += '<div class="wrapTimeline"><div class="timeline">' // Wrap the loop with the timeline
			// Loop through the keyframes
			for (i = 0; i < layerRotationValue.length; i++) {
			    var keyframeTime = layerRotationValue[i].t / layerOutPoint // Convert time
			    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
				var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
				var keyframeTime = parseFloat(keyframeTime.toFixed(2));
				// UI Time
				var keyframeTimeUI = layerRotationValue[i].t / frameRate // Convert time
		    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal

				if (layerRotationValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					var keyframeValue = layerRotationValue[previousKeyframe].e
				} else {
					var keyframeValue = layerRotationValue[i].s
					
					buildBezier = '';
					buildBezierUI = '';
					if (layer.ks.r.x) { // Build out Ease & Wizz Curves
						var easeWizzOutput = layer.ks.r.x
						var matchedCurve;
			            for (var b = 0; b < easeWizzCurves.length; b++) { 
			                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
			                   matchedCurve = easeWizzCurves[b];
			                   var newCurve = cubicBezierOutput(matchedCurve)
			                   buildBezier = 'cubic-bezier'+newCurve;
			                   buildBezierUI += matchedCurve
			                }
			            }
					}
					else { // Build out custom Bezier Curves
						var curveInX = layerRotationValue[i].i.x
						var curveInY = layerRotationValue[i].i.y
						var curveOutX = layerRotationValue[i].o.x
						var curveOutY = layerRotationValue[i].o.y
						var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
						buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
					}

				}
				var previousKeyframe = i - 1
					
				if (previousKeyframe >= 0) {
					var previousKeyTime = layerRotationValue[i-1].t / layerOutPoint // Convert time
					var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
					var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
					var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

					// Not an awesome way of doing this, but I want to nest the info to the keyframe
					var positionLeftPX = layerRotationValue[i-1].t / layerOutPoint
					var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
					var positionLeftPX = positionLeftPX * 360;

					var previousKeyTimeUI = layerRotationValue[i-1].t / frameRate // Convert time
					var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
					var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
					var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2)); // Round the decimal

					var previouskeyframeValue = layerRotationValue[i-1].s[0]

					if (previouskeyframeValue === keyframeValue) {

					}
					else {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValue+'<span class="positionToIcon">&#10142;</span>'+keyframeValue+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
				}
				else {
					keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
				}
				keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'	
			}

			keyframeUI += '<span class="transformProperty">Rotation</span></div></div>' // End the UI Wrap

			/****** UI FOR SCALE *********/
			keyframeUI += '<div class="wrapTimeline"><div class="timeline">' // Wrap the loop with the timeline
			for (i = 0; i < layerScaleValue.length; i++) {
				var keyframeTime = layerScaleValue[i].t / layerOutPoint // Convert time
			    var keyframeTime = keyframeTime.toFixed(2); // Round to 2nd decimal
				var keyframeTime = keyframeTime * 100 // Convert to percentage for keyframe
				var keyframeTime = parseFloat(keyframeTime.toFixed(2));

				var keyframeTimeUI = layerScaleValue[i].t / frameRate // Convert time
		    	var keyframeTimeUI = parseFloat(keyframeTimeUI.toFixed(2)); // Round to 2nd decimal

				if (layerScaleValue[i].s == undefined) { // If the start time is undefined, go back one object and grab end time
					var previousKeyframe = i - 1
					var keyframeValueX = layerScaleValue[previousKeyframe].e[0] / 100
					var keyframeValueY = layerScaleValue[previousKeyframe].e[1] / 100
					var keyframeValueZ = layerScaleValue[previousKeyframe].e[2] / 100

					// Initial State of the Animationm
					var layerScaleValueX = layerScaleValue[previousKeyframe].e[0] / 100
					var layerScaleValueY = layerScaleValue[previousKeyframe].e[1] / 100
					var layerScaleValueZ = layerScaleValue[previousKeyframe].e[2] / 100
				} else {
					var keyframeValueX = layerScaleValue[i].s[0] / 100
					var keyframeValueY = layerScaleValue[i].s[1] / 100
					var keyframeValueZ = layerScaleValue[i].s[2] / 100

					buildBezier = '';
					buildBezierUI = '';
					if (layer.ks.s.x) { // Build out Ease & Wizz Curves
						var easeWizzOutput = layer.ks.s.x
						var matchedCurve;
			            for (var b = 0; b < easeWizzCurves.length; b++) { 
			                if (easeWizzOutput.match(easeWizzCurves[b]) !== null){
			                   matchedCurve = easeWizzCurves[b];
			                   var newCurve = cubicBezierOutput(matchedCurve)
			                   buildBezier = 'cubic-bezier'+newCurve;
			                   buildBezierUI += matchedCurve
			                }
			            }
					}
					else { // Build out custom Bezier Curves
						var curveInX = layerScaleValue[i].i.x
						var curveInY = layerScaleValue[i].i.y
						var curveOutX = layerScaleValue[i].o.x
						var curveOutY = layerScaleValue[i].o.y
						//var buildBezier = 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')'
						//buildBezierUI += 'cubic-bezier('+curveOutX+','+curveOutY+','+curveInX+','+curveInY+')';
						var buildBezier = 'cubic-bezier('+curveOutY+')'
						buildBezierUI += 'cubic-bezier('+curveOutY+')';
					}
				}
				
				var previousKeyframe = i - 1
					
				if (previousKeyframe >= 0) {
					var previousKeyTime = layerScaleValue[i-1].t / layerOutPoint // Convert time
					var previousKeyTime = previousKeyTime.toFixed(2); // Round to 2nd decimal
					var previousKeyTime = previousKeyTime * 100 // Convert to percentage for keyframe
					var updatedTime = keyframeTime - previousKeyTime // Math for the updated width of keyframe

					// Not an awesome way of doing this, but I want to nest the info to the keyframe
					var positionLeftPX = layerScaleValue[i-1].t / layerOutPoint
					var positionLeftPX = positionLeftPX.toFixed(2); // Round to 2nd decimal
					var positionLeftPX = positionLeftPX * 360;

					var previousKeyTimeUI = layerScaleValue[i-1].t / frameRate // Convert time
					var previousKeyTimeUI = parseFloat(previousKeyTimeUI.toFixed(2)); // Round to 2nd decimal
					var updatedTimeUI = keyframeTimeUI - previousKeyTimeUI // Time for the UI
					var updatedTimeUI = parseFloat(updatedTimeUI.toFixed(2)); // Round the decimal

					var previouskeyframeValueX = layerScaleValue[i-1].s[0] / 100
					var previouskeyframeValueY = layerScaleValue[i-1].s[1] / 100
					var previouskeyframeValueZ = layerScaleValue[i-1].s[2] / 100

					if (previouskeyframeValueX === keyframeValueX && previouskeyframeValueY === keyframeValueY && previouskeyframeValueZ === keyframeValueZ) {

					}
					else {
						keyframeUI += '<span class="timelineHighlight" style="left: '+previousKeyTime+'%; width:'+updatedTime+'%"><div class="infoUI" style="left: -'+positionLeftPX+'px"><span class="keyframeLeftData">'+previouskeyframeValueX+' , '+previouskeyframeValueY+' , '+previouskeyframeValueX+'<span class="positionToIcon">&#10142;</span>'+keyframeValueX+' , '+keyframeValueY+' , '+keyframeValueZ+'</span><div class="metaConstants"><span class="durationUI">Duration: '+updatedTimeUI+'s</span><span class="bezier">'+buildBezierUI+'</span></div></div></span>'
					}
				}
				else {
					keyframeUI += '<span class="timelineHighlight" style="left: 0px; width:'+keyframeTime+'%"></span>'
				}
				keyframeUI += '<span class="keyframe" style="left:'+keyframeTime+'%" data-attribute="'+keyframeTimeUI+'"><span class="timeUI">'+keyframeTime+'%</span></span>'	
			}
			keyframeUI += '<span class="transformProperty">Scale</span></div></div>' // End the UI Wrap
		}

		/***************
			END PROPERTIES  
		****************/

		// Conditions for if Height & Width are undefined
		if (layerWidth === undefined) {
			layerWidth = 'auto';
		}
		else {
			layerWidth = layerWidth+'px'
		}
		if (layerHeight === undefined) {
			layerHeight = 'auto';
		}
		else {
			layerHeight = layerHeight+'px'
		}


		/***************
			Build Layer Styles 
		****************/

		layerStyles = ''
		if (layerHasMask === true) { // If a layer has a clipping mask
			layerStyles += (layerClass +'{position: absolute;'+layerPositionValueX+';'+layerPositionValueY+';width: '+layerWidth+';height: '+layerHeight+';transform: '+staticTransform+';transform-origin: '+layerAnchorCompile+';opacity: '+layerOpacityValue+';z-index: -'+layer.ind+';')
		}
		else if (layerMaskParent === 1) { // If a layer has a Track Mat
			layerStyles += (layerClass +'{position: absolute;'+layerPositionValueX+';'+layerPositionValueY+';width: '+layerWidth+';height: '+layerHeight+';transform: '+staticTransform+';transform-origin: '+layerAnchorCompile+';opacity: '+layerOpacityValue+';')
		}
		else {
			
		/***************
			If the layer contains an image
		****************/
			if (layerType === 2) {	
		        firebase.auth().onAuthStateChanged(function(user) {
		        	var url = window.location.href;
					if (user) {
						var project = url.substring(url.indexOf("#")+1);
						var ani = url.substring(url.indexOf("=")+1);
						var project = project.replace(ani, '');
						var project = project.replace('\=', '');
						var userID = user.uid
					} else {
						var project = url.substring(url.indexOf("#")+1);
						var ani = url.substring(url.indexOf("=")+1);
						var usr = url.substring(url.indexOf("?")+1)
						var project = project.replace(ani, '');
						var project = project.replace('\=', '');
						var ani = ani.replace(usr, '');
						var ani = ani.replace('?', '');
						var userID = usr;
					}
					var storage = firebase.storage();
			        var storageRef = storage.ref();
			        var newKey = layerAsset.split("_").pop();
			        var newImagePath = assets[newKey].p
			        var firebaseRef = firebase.database().ref();
			        var firebaseRef = firebaseRef.child(userID).child('projects').child(project).child(ani)
			        firebaseRef.once('value', snap => {
						var status = snap.val();
						var status = status.assetsAttached
						if (status == false) {
							$('.elements-reset').append('<div class="'+layerName+'"></div>');
						}
						else if (status == true) {
							storageRef.child(userID+'/'+ani+'/'+newImagePath).getDownloadURL().then(function(url) {
							var img = url;
							$('.elements-reset').append('<div class="'+layerName+'"><img src="'+img+'"/></div>');
						}).catch(function(error) {
							//console.log(error)
							$('.elements-reset').append('<div class="'+layerName+'" style="background-color: #f4f4f4"></div>');
							});
						}
					}); 
				});
			}
		/***************
			If the layer contains text
		****************/
			else if (layerType === 5) {
				$('.elements-reset').append('<div class="'+layerName+'">'+layer.t.d.k[key].s.t+'</div>');
			}
			// If the layer is basic
			else {
				$('.elements-reset').append('<div class="'+layerName+'"></div>'); // Add the Layers as Div's
			}
			// Need to write smarter way of undefined values, Not sure if I need this anymore
			if (layerPositionValueX == undefined) {
				var firstKeyframeValueX = layerPositionValue[0].s[0] - layerAnchorValueX
				if (firstKeyframeValueX >= canvasWidth) {
					var layerPositionValueX = layerPositionValue[0].s[0] - layerAnchorValueX
					var layerWidthNew =  parseInt(layerWidth);
					var layerPositionValueX = canvasWidth - layerPositionValueX - layerWidthNew;
					var layerPositionValueX = 'right: '+layerPositionValueX+'px'
				}
				else {
					var layerPositionValueX = 'left: '+layerPositionValue[0].s[0] - layerAnchorValueX+'px'
				}	
			}

			if (layerPositionValueY == undefined) {
				var layerPositionValueY = 'top: initial'
			}
			// If the layer color is coming from the shape
			if (layerColor === undefined && layerType === 4) {
				var layerColor = shapeColorRGBA
			}
			// If the layer is a grouptype shape, have a transparent background-color
			if (backgroundColorShape === true) {
				var layerColor = 'transparent'
			}
			
			// If the shape has rounded corners
			if (roundedCorners != undefined) {
				var addRoundedCorners = 'border-radius: '+roundedCorners+'px;';
			}
			else if (shapeCircle != undefined) {
				var addRoundedCorners = 'border-radius: 100%;';
			}
			else {
				var addRoundedCorners = '';
			}

			// If the shape has a stroke
			if (shapeStroke != undefined) {

				var addStroke = shapeStroke
			}
			else {
				var addStroke = ''
			}


			if (layerType === 5) {
				var fontColor = layer.t.d.k[key].s.fc
				var fontColorR = Math.round((fontColor[0] * 255));
				var fontColorG = Math.round((fontColor[1] * 255));
				var fontColorB = Math.round((fontColor[2] * 255));
				var fontColor = 'rgba('+fontColorR+', '+fontColorG+', '+fontColorB+', 100)'
				var fontSize = layer.t.d.k[key].s.s
				var layerColor = 'transparent';
				var addStyles = 'font-family: Helvetica neue; font-size: '+fontSize+'px; font-weight: normal; color: '+fontColor+'';
			}
			else {
				var addStyles = '';
			}
			// Attach the styles
			layerStyles += (layerClass +'{position: absolute;'+layerPositionValueX+';'+layerPositionValueY+';width: '+layerWidth+';height: '+layerHeight+';background-color: '+layerColor+';transform: '+staticTransform+';transform-origin: '+layerAnchorCompile+';opacity: '+layerOpacityValue+';z-index: -'+layer.ind+';'+addStyles+addRoundedCorners+addStroke+'')
		}


		/***************
			Start building the keyframe styles  
		****************/
		
		layerAnimationName = '';

		// Position
		if (layerPositionAnimated === 1 || layerPositionSplit === false) {
			layerAnimationName += (layerName+'-position, ')
		}

		// Position
		if (layerPositionXAnimated === 1 && layerPositionYAnimated === 1 ) {
			layerAnimationName += (layerName+'-positionX, ')
			layerAnimationName += (layerName+'-positionY, ')
		}

		// Position X
		if (layerPositionXAnimated === 1 && layerPositionYAnimated === 0 ) {
			layerAnimationName += (layerName+'-positionX, ')
		}

		// Position Y
		if (layerPositionXAnimated === 0 && layerPositionYAnimated === 1 ) {
			layerAnimationName += (layerName+'-positionY, ')
		}

		// Anchor
		if (layerAnchorAnimated === 1) {
			layerAnimationName += (layerName+'-anchor, ')
		}

		// Opacity
		if (layerOpacityAnimated === 1) {
			layerAnimationName += (layerName+'-opacity, ')
		}

		// Scale & Rotation
		if (layerScaleAnimated === 1 && layerRotationAnimated === 1) {
			layerAnimationName += (layerName+'-transform, ')
		}

		// Rotation
		if (layerRotationAnimated === 1 && layerScaleAnimated === 0) {
			layerAnimationName += (layerName+'-rotation, ');
		}

		// Scale
		if (layerScaleAnimated === 1 && layerRotationAnimated === 0) {
			layerAnimationName += (layerName+'-scale, ')
		}

		var layerAnimationName = layerAnimationName.replace(/,([^,]*)$/,'') // Remove the last comma

		if (layerScaleAnimated === 1 || layerRotationAnimated === 1 || layerOpacityAnimated ===1 || layerPositionXAnimated === 1 || layerPositionYAnimated === 1 || layerPositionAnimated === 1) {
			layerStyles += ('animation-name: '+layerAnimationName+';')
			layerStyles += ('animation-fill-mode: forwards;animation-duration: '+layerDuration+'s;animation-iteration-count: 1;animation-play-state: running;}')
			$("#dynamicStylesheet").append(layerStyles + keyframeStyles)
		}
		else {
			$("#dynamicStylesheet").append(layerStyles + '}')
		}

		

		/***************
			Beautify CSS  
		****************/

		// Format the base styles
		var cssOut = layerStyles;
		
		var cssOut = cssOut.replace(/^/g, '<span class="name">')
		var cssOut = cssOut.replace(/{/g, '</span> {');
		var cssOut = cssOut.replace(/(px)/g, '<span class="unit">px</span>');
		var cssOut = cssOut.replace(/(deg)/g, '<span class="unit">deg</span>');
		var cssOut = cssOut.replace(/(\d+)/g,"<span class='integer'>$1</span>"); 
		var cssOut = cssOut.replace('position:', '<span class="property">position</span>:');
		var cssOut = cssOut.replace('left:', '<span class="property">left</span>:');
		var cssOut = cssOut.replace('right:', '<span class="property">right</span>:');
		var cssOut = cssOut.replace('top:', '<span class="property">top</span>:');
		var cssOut = cssOut.replace('bottom:', '<span class="property">bottom</span>:')
		var cssOut = cssOut.replace('width:', '<span class="property">width</span>:');
		var cssOut = cssOut.replace('height:', '<span class="property">height</span>:');
		var cssOut = cssOut.replace('background-color:', '<span class="property">background-color</span>:');
		var cssOut = cssOut.replace('transform:', '<span class="property">transform</span>:');
		var cssOut = cssOut.replace('transform-origin:', '<span class="property">transform-origin</span>:');
		var cssOut = cssOut.replace('animation-play-state:', '<span class="property">animation-play-state</span>:');
		var cssOut = cssOut.replace('opacity:', '<span class="property">opacity</span>:');
		var cssOut = cssOut.replace('z-index:', '<span class="property">z-index</span>:');
		var cssOut = cssOut.replace('border-radius:', '<span class="property">border-radius</span>:');
		var cssOut = cssOut.replace('font-family:', '<span class="property">font-family</span>:');
		var cssOut = cssOut.replace('font-size:', '<span class="property">font-size</span>:');
		var cssOut = cssOut.replace('font-weight:', '<span class="property">font-weight</span>:');
		var cssOut = cssOut.replace('color:', '<span class="property">color</span>:');
		var cssOut = cssOut.replace('animation-name:', '<span class="property">animation-name</span>:');
		var cssOut = cssOut.replace('border:', '<span class="property">border</span>:');
		var cssOut = cssOut.replace('animation-fill-mode:', '<span class="property">animation-fill-mode</span>:');
		var cssOut = cssOut.replace('animation-duration:', '<span class="property">animation-duration</span>:');
		var cssOut = cssOut.replace('animation-iteration-count:', '<span class="property">animation-iteration-count</span>:');
		var cssOut = cssOut.replace(/:/g, ':<span class="value">');
		var cssOut = cssOut.replace(/;/g, '</span>;<br />');
		var cssOut = cssOut.replace(/}/g, '}<br /><br />');
		var cssOut = cssOut.replace(/(?:\{)/g, '{<br />');

		// Format the keyframe animation
		var keyframeStyles = keyframeStyles.replace(/@keyframes/g, '<span class="keyframe">@keyframes</span>')
		var keyframeStyles = keyframeStyles.replace(/{/g, '{<br />');
		var keyframeStyles = keyframeStyles.replace(/}/g, '}<br />');
		var keyframeStyles = keyframeStyles.replace(/%/g, '<span class="unit">%</span>');
		var keyframeStyles = keyframeStyles.replace(/(\d+)/g,"<span class='integer'>$1</span>"); 

		var keyframeStyles = keyframeStyles.replace(/position:/g, '<span class="property">position</span>:')
		var keyframeStyles = keyframeStyles.replace(/left:/g, '<span class="property">left</span>:')
		var keyframeStyles = keyframeStyles.replace(/right:/g, '<span class="property">right</span>:')
		var keyframeStyles = keyframeStyles.replace(/top:/g, '<span class="property">top</span>:')
		var keyframeStyles = keyframeStyles.replace(/bottom:/g, '<span class="property">bottom</span>:')
		var keyframeStyles = keyframeStyles.replace(/width:/g, '<span class="property">width</span>:')
		var keyframeStyles = keyframeStyles.replace(/height:/g, '<span class="property">height</span>:')
		var keyframeStyles = keyframeStyles.replace(/animation-timing-function:/g, '<span class="property">animation-timing-function</span>:')
		var keyframeStyles = keyframeStyles.replace(/background-color:/g, '<span class="property">background-color</span>:')
		var keyframeStyles = keyframeStyles.replace(/transform:/g, '<span class="property">transform</span>:')
		var keyframeStyles = keyframeStyles.replace(/transform-origin:/g, '<span class="property">transform-origin</span>:')
		var keyframeStyles = keyframeStyles.replace(/opacity:/g, '<span class="property">opacity</span>:')

		var keyframeStyles = keyframeStyles.replace(/:/g, ':<span class="value">');
		var keyframeStyles = keyframeStyles.replace(/;/g, '</span>;<br />');

		var keyframeStyles = keyframeStyles.replace(/(px)/g, '<span class="unit">px</span>');
		var keyframeStyles = keyframeStyles.replace(/(deg)/g, '<span class="unit">deg</span>');

		if (layerScaleAnimated === 1 || layerRotationAnimated === 1 || layerOpacityAnimated ===1 || layerPositionXAnimated === 1 || layerPositionYAnimated === 1 || layerPositionAnimated === 1) {
			$('.cssOutput').append(cssOut + keyframeStyles);
		}
		else {
			$('.cssOutput').append(cssOut + '}');
		}

		// Format the and highlight
		if (layerHasMask === true) {
			var buildSVGclean = buildSVG.replace(/"\s*(.*?)\s*"/g, '"<values>$1</values>"');
			var buildSVGclean = buildSVGclean.replace(/class=/g, '<span class="property">class</span>=');
			var buildSVGclean = buildSVGclean.replace(/id=/g, '<span class="property">id</span>=');
			var buildSVGclean = buildSVGclean.replace(/width=/g, '<span class="property">width</span>=');
			var buildSVGclean = buildSVGclean.replace(/height=/g, '<span class="property">height</span>=');
			var buildSVGclean = buildSVGclean.replace(/clip-rule=/g, '<span class="property">clip-rule</span>=');
			var buildSVGclean = buildSVGclean.replace(/fill=/g, '<span class="property">fill</span>=');
			var buildSVGclean = buildSVGclean.replace(/attributeName=/g, '<span class="property">attributeName</span>=');
			var buildSVGclean = buildSVGclean.replace(/begin=/g, '<span class="property">begin</span>=');
			var buildSVGclean = buildSVGclean.replace(/dur=/g, '<span class="property">dur</span>=');
			var buildSVGclean = buildSVGclean.replace(/from=/g, '<span class="property">from</span>=');
			var buildSVGclean = buildSVGclean.replace(/to=/g, '<span class="property">to</span>=');
			var buildSVGclean = buildSVGclean.replace(/values=/g, '<span class="property">values</span>=');
			var buildSVGclean = buildSVGclean.replace(/calcMode=/g, '<span class="property">calcMode</span>=');
			var buildSVGclean = buildSVGclean.replace(/keySplines=/g, '<span class="property">keySplines</span>=');
			var buildSVGclean = buildSVGclean.replace(/mask=/g, '<span class="property">mask</span>=');
			var buildSVGclean = buildSVGclean.replace(/d=/g, '<span class="property">d</span>=');
			var buildSVGclean = buildSVGclean.replace(/data-attribute=/g, '<span class="property">data-attribute</span>=');

			

			var buildSVGclean = buildSVGclean.replace(/<svg/g, '&#60;<span class="htmlElement">svg</span></span>');
			var buildSVGclean = buildSVGclean.replace(/<mask/g, '<br /><span class="indent1">&#60;<span class="htmlElement">mask</span></span>');
			var buildSVGclean = buildSVGclean.replace(/<g/g, '<br /><span class="indent1">&#60;<span class="htmlElement">g</span></span>');
			var buildSVGclean = buildSVGclean.replace(/<path/g, '<br /><span class="indent2">&#60;<span class="htmlElement">path</span></span>');
			var buildSVGclean = buildSVGclean.replace(/<rect/g, '<br /><span class="indent2">&#60;<span class="htmlElement">rect</span></span>');
			var buildSVGclean = buildSVGclean.replace(/<animate/g, '<br /><span class="indent3">&#60;<span class="htmlElement">animate</span></span>');

			var buildSVGclean = buildSVGclean.replace(/<\/svg>/g, '<br />&#60;/<span class="htmlElement">svg</span>&#62;');
			var buildSVGclean = buildSVGclean.replace(/<\/mask>/g, '<br /><span class="indent1">&#60;/<span class="htmlElement">mask</span>&#62;</span>');
			var buildSVGclean = buildSVGclean.replace(/<\/g>/g, '<br /><span class="indent1">&#60;/<span class="htmlElement">g</span>&#62;</span>');
			var buildSVGclean = buildSVGclean.replace(/<\/path>/g, '<br /><span class="indent2">&#60;/<span class="htmlElement">path</span>&#62;</span>');
			var buildSVGclean = buildSVGclean.replace(/<\/rect>/g, '<br /><span class="indent2">&#60;/<span class="htmlElement">rect</span>&#62;</span>');
			var buildSVGclean = buildSVGclean.replace(/<\/animate>/g, '<br /><span class="indent3">&#60;/<span class="htmlElement">animate</span>&#62;</span>');


		}

		/***************
			Build Cue UI
		****************/
		// If layer has mask (svg) & is animated
		if (layerHasMask === true && layerScaleAnimated === 1 || layerRotationAnimated === 1 || layerOpacityAnimated ===1 || layerPositionXAnimated === 1 || layerPositionYAnimated === 1 || layerPositionAnimated === 1) {
			$('.layerOutput').append('<div class="layer svg" id="'+layerName+'-ui"><span class="layerHide"></span><span class="layerTapTarget"></span><span class="layerName">'+layer.nm+'</span><span class="trigger"></span><div class="transform">'+keyframeUI+'<span class="defaultTimeline"></span></div></div>')
		}
		// If layer is a div and is animated
		else if (layerScaleAnimated === 1 || layerRotationAnimated === 1 || layerOpacityAnimated ===1 || layerPositionXAnimated === 1 || layerPositionYAnimated === 1 || layerPositionAnimated === 1) {
			$('.layerOutput').append('<div class="layer" id="'+layerName+'-ui"><span class="layerHide"></span><span class="layerTapTarget"></span><span class="layerName">'+layer.nm+'</span><span class="trigger"></span><div class="transform">'+keyframeUI+'<span class="defaultTimeline"></span></div></div>')
		}
		// If it is an animated svg
		else if (layerHasMask === true && maskPointsAnimated === 1){
			$('.layerOutput').append('<div class="layer svg" id="'+layerName+'-ui"><span class="layerHide"></span><span class="layerTapTarget"></span><span class="layerName">'+layer.nm+'</span><span class="trigger"></span><div class="transform">'+keyframeUI+'<span class="defaultTimeline"></span></div></div>')
		}
		// If the layer is static
		else {
			$('.layerOutput').append('<div class="layer" id="'+layerName+'-ui"><span class="layerHide"></span><span class="layerName">'+layer.nm+'</span><span class="noMotion">This div doesnt contain any animation properties</span></div>')
		}
		// Push the HTML markup to the code tab
		if (layerHasMask === true) {
			var htmlOut = buildSVGclean;
		}
		else {
			var htmlOut = '&#60;div class="<span class="className">'+layerName+'</span>"&#62;&#60;/div&#62;<br />';
		}
		$('.htmlOutput').append(htmlOut)

	}) // End Each

	function cubicBezierOutput(easeAndWizzBezier){
		if (easeAndWizzBezier == 'inSine'){
			easeAndWizzBezier = '(0.47, 0, 0.745, 0.715)';
		}
		if (easeAndWizzBezier == 'outSine'){
			easeAndWizzBezier = '(0.39, 0.575, 0.565, 1)';
		}
		if (easeAndWizzBezier == 'inOutSine'){
			easeAndWizzBezier = '(0.445, 0.05, 0.55, 0.95)';
		}
		if (easeAndWizzBezier == 'inQuad'){
			easeAndWizzBezier = '(0.55, 0.085, 0.68, 0.53)';
		}
		if (easeAndWizzBezier == 'outQuad'){
			easeAndWizzBezier = '(0.25, 0.46, 0.45, 0.94)';
		}
		if (easeAndWizzBezier == 'inOutQuad'){
			easeAndWizzBezier = '(0.455, 0.03, 0.515, 0.955)';
		}
		if (easeAndWizzBezier == 'inCubic'){
			easeAndWizzBezier = '(0.55, 0.055, 0.675, 0.19)';
		}
		if (easeAndWizzBezier == 'outCubic'){
			easeAndWizzBezier = '(0.215, 0.61, 0.355, 1)';
		}
		if (easeAndWizzBezier == 'inOutCubic'){
			easeAndWizzBezier = '(0.645, 0.045, 0.355, 1)';
		}
		if (easeAndWizzBezier == 'inQuart'){
			easeAndWizzBezier = '(0.895, 0.03, 0.685, 0.22)';
		}
		if (easeAndWizzBezier == 'outQuart'){
			easeAndWizzBezier = '(0.165, 0.84, 0.44, 1)';
		}
		if (easeAndWizzBezier == 'inOutQuart'){
			easeAndWizzBezier = '(0.77, 0, 0.175, 1)';
		}
		if (easeAndWizzBezier == 'inQuint'){
			easeAndWizzBezier = '(0.755, 0.05, 0.855, 0.06)';
		}
		if (easeAndWizzBezier == 'outQuint'){
			easeAndWizzBezier = '(0.23, 1, 0.32, 1)';
		}
		if (easeAndWizzBezier == 'inOutQuint'){
			easeAndWizzBezier = '(0.86, 0, 0.07, 1)';
		}
		if (easeAndWizzBezier == 'inExpo'){
			easeAndWizzBezier = '(0.95, 0.05, 0.795, 0.035)';
		}
		if (easeAndWizzBezier == 'outExpo'){
			easeAndWizzBezier = '(0.19, 1, 0.22, 1)';
		}
		if (easeAndWizzBezier == 'inOutExpo'){
			easeAndWizzBezier = '(1, 0, 0, 1)';
		}
		if (easeAndWizzBezier == 'inCirc'){
			easeAndWizzBezier = '(0.6, 0.04, 0.98, 0.335)';
		}
		if (easeAndWizzBezier == 'outCirc'){
			easeAndWizzBezier = '(0.075, 0.82, 0.165, 1)';
		}
		if (easeAndWizzBezier == 'inOutCirc'){
			easeAndWizzBezier = '(0.785, 0.135, 0.15, 0.86)';
		}
		if (easeAndWizzBezier == 'inBack'){
			easeAndWizzBezier = '(0.6, -0.28, 0.735, 0.045)';
		}
		if (easeAndWizzBezier == 'outBack'){
			easeAndWizzBezier = '(0.175, 0.885, 0.32, 1.275)';
		}
		if (easeAndWizzBezier == 'inOutBack'){
			easeAndWizzBezier = '(0.68, -0.55, 0.265, 1.55)';
		}
		
		return easeAndWizzBezier;
	}


	// Resize Canvas
	function resizeAnimation(){
		var sideBarWidth = $('.cuePanel').outerWidth(true) + 45;
		var canvasWidth = $('.canvas').outerWidth(true);
		var canvasHeight = $('.canvas').outerHeight(true);
		var openWidth = $(window).outerWidth(true) - sideBarWidth;
		var openHeight = $(window).outerHeight(true) - 73;
		
		if (canvasHeight > canvasWidth) {
			canvasWidth = (openHeight / canvasHeight) * .95;
		}
		else if (canvasWidth > canvasHeight) {
			canvasWidth = (openWidth / canvasWidth) * .95;
		}
		if (canvasWidth > 1){
			canvasWidth = 1;
		}

		//var openWidth2 = $(window).outerWidth(true);

		// Variation for Large version of animation
		/*
		var canvasWidthLarge = $('.canvas').outerWidth(true);
		var openWidthLarge = $(window).outerWidth(true);
		canvasWidthLarge = (openWidthLarge / canvasWidthLarge) * .7;
		if (canvasWidthLarge > 1){
			canvasWidthLarge = 1;
		}*/

		marginLeft = ((openWidth - $('.canvas').outerWidth(true)*canvasWidth)/2 - 18)+'px';
		marginTop = (($(window).height() - $('.canvas').outerHeight(true)*canvasWidth)/2);
		marginTop = marginTop + 28+'px';

		//marginLeftLarge = ((openWidth2 - $('.canvas').outerWidth(true)*canvasWidth)/2)+'px';
		//marginTopLarge = (($(window).height() - $('.canvas').outerHeight(true)*canvasWidth)/4.5)+'px';
		
		var scaleVal = 'scale3d('+canvasWidth+','+canvasWidth+',1)';
		$('.animations').css({'top':0,'margin-top':marginTop, 'margin-left':marginLeft});
		$('.canvas').css({'transform':scaleVal});

	}
	resizeAnimation();
	$(window).resize(function(){
		resizeAnimation();
	});

	// Layer UI Controls
	$('.trigger').click(function(){
		$(this).parent('.layer').toggleClass('expand');
		$(this).nextAll('.transform').toggleClass('expand');
		$(this).toggleClass('collapse');

		$(this).parent('.layer').find('.timelineHighlight').removeClass('active');
		$(this).parent('.layer').find('.keyframe').removeClass('active');
		$(this).parent('.layer').find('.keyframe').find('.timeUI').removeClass('show');
		$(this).parent('.layer').find('.timeline').parent('.wrapTimeline').removeClass('open');
	});

	// Layer UI Controls -- This is a duplicate of the above, can combine at some point
	$('.layerTapTarget').click(function(){
		$(this).parent('.layer').toggleClass('expand');
		$(this).nextAll('.transform').toggleClass('expand');
		$(this).parent('.layer').find('.trigger').toggleClass('collapse');

		$(this).parent('.layer').find('.timelineHighlight').removeClass('active');
		$(this).parent('.layer').find('.keyframe').removeClass('active');
		$(this).parent('.layer').find('.keyframe').find('.timeUI').removeClass('show');
		$(this).parent('.layer').find('.timeline').parent('.wrapTimeline').removeClass('open');
	});

	// Show Element on Hover
	$('.layerTapTarget').mouseenter(function(){
		var getName = $(this).parent('.layer').attr('id');
		var getName = '.'+getName
		var getName = getName.replace('-ui', '');
		$(getName).addClass('selectedElement')
	})

	// Show Element on Hover
	$('.layerTapTarget').mouseout(function(){
		var getName = $(this).parent('.layer').attr('id');
		var getName = '.'+getName
		var getName = getName.replace('-ui', '');
		$(getName).removeClass('selectedElement')
	})

	// Show UI Layer Element on Hover
	$('.elements-reset > div, .elements-reset > svg').mouseenter(function(){
		var className = $(this).attr('class');
    	var className = '#'+className+'-ui';
    	$(className).addClass('hovered');
	})

	// Show UI Layer Element on Hover
	$('.elements-reset > div, .elements-reset > svg').mouseout(function(){
		var className = $(this).attr('class');
    	var className = '#'+className+'-ui';
    	$(className).removeClass('hovered');
	})

	// Timeline Properties i.e. Position, Opacity, Rotation etc.
	$('.timelineHighlight').click(function(){
		$('.timelineHighlight').not(this).each(function(){
	        $(this).removeClass('active');
	        $(this).prev('.keyframe').removeClass('active');
	        $(this).prev('.keyframe').find('.timeUI').removeClass('show');
			$(this).next('.keyframe').removeClass('active');
			$(this).next('.keyframe').find('.timeUI').removeClass('show');
			$(this).parent('.timeline').parent('.wrapTimeline').removeClass('open');
	    });
	    if ($('.timelineHighlight').hasClass('active')) {
	    	$(this).removeClass('active');
			$(this).prev('.keyframe').removeClass('active');
			$(this).prev('.keyframe').find('.timeUI').removeClass('show');
			$(this).next('.keyframe').removeClass('active');
			$(this).next('.keyframe').find('.timeUI').removeClass('show');
			$(this).parent('.timeline').parent('.wrapTimeline').removeClass('open');
	    }
	    else {
			$(this).addClass('active');
			$(this).prev('.keyframe').addClass('active');
			$(this).prev('.keyframe').find('.timeUI').addClass('show');
			$(this).next('.keyframe').addClass('active');
			$(this).next('.keyframe').find('.timeUI').addClass('show');
			$(this).parent('.timeline').parent('.wrapTimeline').addClass('open');
		}
	})

	// Prevent collapse of keyframe data
	$(".timelineHighlight div").click(function(e) { 
		e.stopPropagation(); 
	});

	// Show / Hide Layers
	$('.layerHide').click(function(){
		$(this).toggleClass('hidden');
		var getName = $(this).parent('.layer').attr('id');
		var getName = getName.replace('-ui', '');
		var getName = '.'+getName;
		$(getName).toggle()
	});

	$('.showCSS').click(function(){
		$('.cssOutput').show();
		$('.htmlOutput').hide();
		$('.showCSS').addClass('active');
		$('.showHTML').removeClass('active');
	});

	$('.showHTML').click(function(){
		$('.cssOutput').hide();
		$('.htmlOutput').show();
		$('.showCSS').removeClass('active');
		$('.showHTML').addClass('active');
	});

	$('.closePanel').click(function(){
		$('.cuePanel').toggleClass('close');
		$(this).toggleClass('openPanel');
		$('.cueTitle').toggleClass('collapse');
		$(".canvas").toggleClass("large");
	    $(".animations").toggleClass("open");
		resizeAnimation();
	})

	$('.playAnimation').click(function(){
		$('.elements-reset').hide(0).show(0);
	});

	function maskAnimation(count) {
		$('.playAnimation').click(function(){
			if (document.getElementById('animate'+count)) {
				document.getElementById('animate'+count).beginElement();
				$('.elements-reset').hide().show();
			}
		});
	}

	/**************
		Tab Functions: Timeline, Code, Shortcuts
	**************/

	$('.codeTab').click(function(){
		$(this).addClass('active');
		$('.timelineTab').removeClass('active');
		$('.layerOutput').hide();
		$('.markupOutput').show();
	});

	$('.timelineTab').click(function(){
		$(this).addClass('active');
		$('.codeTab').removeClass('active');
		$('.layerOutput').show();
		$('.markupOutput').hide();
	});

	// Key Commands
	$(document).on('keyup',function(evt) {
	  	if (evt.keyCode == 13) {
	      $('.elements-reset').hide(0).delay(50).show(0);
	    }
	});


	/**************
		Copy to Clipboard
	**************/
	var copyBtn = document.querySelector('.copy');
    var codeCopied = document.querySelector('.codeCopied');

    function SelectText(element) {
      var doc = document
          , text = doc.getElementById(element)
          , range, selection;   
      if (doc.body.createTextRange) {
          range = document.body.createTextRange();
          range.moveToElementText(text);
          range.select();
      } else if (window.getSelection) {
          selection = window.getSelection();        
          range = document.createRange();
          range.selectNodeContents(text);
          selection.removeAllRanges();
          selection.addRange(range);
      }
    }
		copyBtn.addEventListener('click', function (event) {
			if ($('.showCSS').hasClass('active')) {
	            SelectText('cssCopy');
	        }
	        else {
	        	SelectText('htmlCopy');
	        }
	        document.execCommand('copy');
	        document.getSelection().removeAllRanges();
	        codeCopied.classList.add('out');
	        setTimeout(function() {
	            codeCopied.classList.remove('out');
	        }, 1500);
	    });

	} // end

	/**************
		Download File
	**************/
  	function downloadInnerHtml(htmloutput, hOut, mimeType) {
  		var animationName = 'projectAni'
	    var cssOut = $('.cssOutput').text();
	    var myHTML = $('.elements-reset').html();
	    var fullHtml = "<!doctype html><html><head><title>" + animationName + "</title><style>" + cssOut + "</style></head><body>" + myHTML + "</body></html>"
	    $('body').prepend('<a id="downloader"></a>');
	    var mimeType = mimeType || 'data:text/plain;charset=utf-8';
	    var linkType = $('#downloader');
	    linkType.attr('download', animationName+'.html');
	    linkType[0].setAttribute('href', 'data:' + mimeType + ';charset=utf-8,' + encodeURIComponent(fullHtml));
	    linkType[0].click();
	    linkType.remove();
	    console.log('Need to format this file better')
	}
    
    $('.download').click(function(){
        var animationName = $('#fileMgmt li.active').text();
		var htmloutput = animationName+'.html';
		downloadInnerHtml(htmloutput, 'html-output','text/html');
    });

	/**************
		Resize Panel
	**************/
	
	$('.cuePanel').resizable({
	    handles: {'w' : '.ui-resizable-w'},
	    minWidth: 300,
	    maxWidth: 700
	});


	/**************
		Cue Support
	**************/

	$(".expandCollapse").on("click", function () {
		$(this).toggleClass('open');
		$('.cueSupport').toggleClass('open');
	});

}); // End Ready